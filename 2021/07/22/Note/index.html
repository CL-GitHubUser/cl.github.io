<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/cl.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/cl.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/cl.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/cl.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/cl.github.io/css/main.css">


<link rel="stylesheet" href="/cl.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cl-githubuser.github.io","root":"/cl.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="数据库1. B树为什么可以减少IO次数磁盘IO：寻道时间，旋转延迟，传输时间；每次读取加载需要地址的数据到内存，而且相邻地址的数据也加载到内存缓冲区，相当于一页，一页树相当于一次IO。数据库索引存在磁盘上，利用索引查询时，只能逐页加载每个磁盘页，这个磁盘页对应索引树的节点。 B+树非叶子结点保存的是叶子结点数据的指针，不是真实的数据，所以中间结点的存储占用的空间较少，能存更多的数据，更加矮胖，效率">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://cl-githubuser.github.io/2021/07/22/Note/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据库1. B树为什么可以减少IO次数磁盘IO：寻道时间，旋转延迟，传输时间；每次读取加载需要地址的数据到内存，而且相邻地址的数据也加载到内存缓冲区，相当于一页，一页树相当于一次IO。数据库索引存在磁盘上，利用索引查询时，只能逐页加载每个磁盘页，这个磁盘页对应索引树的节点。 B+树非叶子结点保存的是叶子结点数据的指针，不是真实的数据，所以中间结点的存储占用的空间较少，能存更多的数据，更加矮胖，效率">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/80466/Desktop/秋招/Note/数据库死锁.png">
<meta property="article:published_time" content="2021-07-22T02:14:16.451Z">
<meta property="article:modified_time" content="2021-08-11T12:41:44.383Z">
<meta property="article:author" content="CL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/80466/Desktop/秋招/Note/数据库死锁.png">

<link rel="canonical" href="https://cl-githubuser.github.io/2021/07/22/Note/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/cl.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/cl.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/cl.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cl-githubuser.github.io/2021/07/22/Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/cl.github.io/images/avatar.gif">
      <meta itemprop="name" content="CL">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-22 10:14:16" itemprop="dateCreated datePublished" datetime="2021-07-22T10:14:16+08:00">2021-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-11 20:41:44" itemprop="dateModified" datetime="2021-08-11T20:41:44+08:00">2021-08-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1-B树为什么可以减少IO次数"><a href="#1-B树为什么可以减少IO次数" class="headerlink" title="1. B树为什么可以减少IO次数"></a>1. B树为什么可以减少IO次数</h3><p>磁盘IO：寻道时间，旋转延迟，传输时间；每次读取加载需要地址的数据到内存，而且相邻地址的数据也加载到内存缓冲区，相当于一页，一页树相当于一次IO。数据库索引存在磁盘上，利用索引查询时，只能逐页加载每个磁盘页，这个磁盘页对应索引树的节点。</p>
<p>B+树非叶子结点保存的是叶子结点数据的指针，不是真实的数据，所以中间结点的存储占用的空间较少，能存更多的数据，更加矮胖，效率更高。</p>
<h3 id="2-innodb四大特性"><a href="#2-innodb四大特性" class="headerlink" title="2. innodb四大特性"></a>2. innodb四大特性</h3><h4 id="2-1-插入缓冲（Insert-buffer）"><a href="#2-1-插入缓冲（Insert-buffer）" class="headerlink" title="2.1 插入缓冲（Insert buffer）"></a>2.1 插入缓冲（Insert buffer）</h4><p>对于非聚集索引和非唯一索引有效，插入数据时下判断插入的非聚集索引页是否在缓存池中，如果在就直接插入；如果不在，先放入insert buffer ，按照一定频率进行合并操作，这样就可以将多个插入合并到一个操作，减少随机IO带来的性能损耗。</p>
<h4 id="2-2-二次写（double-write"><a href="#2-2-二次写（double-write" class="headerlink" title="2.2 二次写（double write)"></a>2.2 二次写（double write)</h4><p>flush操作：将内存中的 数据更新到磁盘中并将redo log的checkpoint前推，保持磁盘和内存的数据一致性。</p>
<p>double write缓存时位于系统表空间的存储区域，用来缓存innodb的数据页从缓存池中flush之后与写入数据文件之前，当操作系统或者书库在写磁盘的过程中崩溃就可以用double write缓存池中的树页备份进行crash恢复。</p>
<h4 id="2-3-自适应哈希索引"><a href="#2-3-自适应哈希索引" class="headerlink" title="2.3 自适应哈希索引"></a>2.3 自适应哈希索引</h4><p>innodb存储引擎会监控对表上二级索引的找查找，如果发现某二级索引被频繁访问，就会建立哈希索引来提升索引速度。但是会占用innodb buffer pool。</p>
<h4 id="2-4-预读"><a href="#2-4-预读" class="headerlink" title="2.4 预读"></a>2.4 预读</h4><p><a target="_blank" rel="noopener" href="http://www.mybatis.cn/archives/941.html">一级索引与二级索引</a></p>
<p>innodb的逻辑存储结构：表空间-&gt; 段（segment）-&gt;区（extent)-&gt;页（page)-&gt;行（row)</p>
<p>线性预读：是否将写一个extent预读到buffer pool中。</p>
<p>随机预读：如果一个extent的 一些page被发现在buffer pool中，就将该extent剩余的page加载到buffer pool中。</p>
<h3 id="3-MyISAM与innoDB区别"><a href="#3-MyISAM与innoDB区别" class="headerlink" title="3. MyISAM与innoDB区别"></a>3. MyISAM与innoDB区别</h3><p>1.后者支持事务</p>
<p>2.后者有行锁</p>
<p>3.前者强调性能，每次查询具有原子性，执行速度比innodb快，但是不支持事务。后者支持事务，外键等功能，具有事务，回滚，崩溃修复能力的事务安全型表。</p>
<p>4.后者支持外键</p>
<p>5.后者支持mvcc。</p>
<h3 id="4-索引"><a href="#4-索引" class="headerlink" title="4.索引"></a>4.索引</h3><h4 id="4-1-MyISAM"><a href="#4-1-MyISAM" class="headerlink" title="4.1 MyISAM"></a>4.1 MyISAM</h4><p>B+树叶结点存放data域是数据记录的地址。在索引检索的时候，先按照B+树的索引算法找指定的key,如果存在则取出其data域的值，然后以data域的值为内存地址取出相应的数据记录。（非聚集索引）</p>
<h3 id="4-2-innoDB"><a href="#4-2-innoDB" class="headerlink" title="4.2 innoDB"></a>4.2 innoDB</h3><p>其数据文件本身就是索引文件。相比前者，索引文件和数据文件是分离的，其表文件就是一个B+树的索引结构，树的叶子节点的data域保存了完整的数据，这个索引的key是数据表主键，数据表本身就是主索引（聚集索引）。其余的索引都是辅助索引，辅助索引data域的数据是主键值而不是地址。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuyafeng/p/11350873.html">两者索引</a></p>
<h3 id="4-3-事务的四大特性"><a href="#4-3-事务的四大特性" class="headerlink" title="4.3 事务的四大特性"></a>4.3 事务的四大特性</h3><p>原子性（Atomictity）:事务是最小的执行单元，不允许分割。事务的动作要么全部完成，要么完全不起作用。</p>
<p>一致性（Consistency）：执行事务前后，是从一个一致性状态转移到下一个一致性状态，举一个给钱的例子。</p>
<p>隔离性（Isolation）:并发访问数据库的时候，各个事务直接不能相互干扰。</p>
<p>持久性（Durability)：一个事务被提交之后，对数据库所造成的影响是持久性的，即使数据库发生故障也不应该有任何影响。</p>
<h3 id="4-4-数据库的三大范式"><a href="#4-4-数据库的三大范式" class="headerlink" title="4.4 数据库的三大范式"></a>4.4 数据库的三大范式</h3><p>范式一：列是最小信息单元，无法再次被分割</p>
<p>范式二：在满足一的基础上，非主键列不能对主键列形成部份依赖</p>
<p>范式三：在满足一二，的基础上，非主键列之间不能被形成传递依赖</p>
<h3 id="4-5-数据库并发操作带来的问题"><a href="#4-5-数据库并发操作带来的问题" class="headerlink" title="4.5 数据库并发操作带来的问题"></a>4.5 数据库并发操作带来的问题</h3><ul>
<li><p>脏读：当事务A访问数据并进行了修改，还未提交，此时，事务B也对该数据进行了访问，读取了数据，但同时事务A进行了回滚，事务B读取的数据便是“脏数据，这便是脏读。</p>
</li>
<li><p>不可重复读：指事务A在访问数据后，事务B之后对该数据进行了修改，事务A再次读取的时候域上次读取的数据不相同。</p>
</li>
<li><p>幻读：与不可重复读类似，当事务A读取一次数据后，事务B又增加了几条数据到该表中，事务A读取的时候发现多了一些数据。</p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
</li>
</ul>
<h3 id="4-6-事务的隔离级别"><a href="#4-6-事务的隔离级别" class="headerlink" title="4.6 事务的隔离级别"></a>4.6 事务的隔离级别</h3><ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。(innodb默认级别)</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<h3 id="4-7-锁"><a href="#4-7-锁" class="headerlink" title="4.7 锁"></a>4.7 锁</h3><h4 id="4-7-1-间隙锁是什么"><a href="#4-7-1-间隙锁是什么" class="headerlink" title="4.7.1 间隙锁是什么"></a>4.7.1 间隙锁是什么</h4><p>rr隔离级别下才会有间隙锁，</p>
<p>select …for update会添加行级锁，没有索引的话会将排查的行全部加锁</p>
<h4 id="4-7-2-死锁"><a href="#4-7-2-死锁" class="headerlink" title="4.7.2 死锁"></a>4.7.2 死锁</h4><p><strong>情况一：</strong>线程A访问表１并加独占锁，线程B访问表２也加了独占锁，此时线程一需要访问表２，线程二也要访问表１，双方给都不释放锁，就形成了死锁。</p>
<p><strong>情况二：</strong><img src="C:\Users\80466\Desktop\秋招\Note\数据库死锁.png" alt="死锁图像"></p>
<h3 id="4-8-分库分表"><a href="#4-8-分库分表" class="headerlink" title="4.8 分库分表"></a>4.8 分库分表</h3><p>实现读写分离,增加并发性</p>
<h4 id="4-8-1-垂直分区"><a href="#4-8-1-垂直分区" class="headerlink" title="4.8.1 垂直分区"></a>4.8.1 垂直分区</h4><p>根据数据库里面的数据表的相关性进行拆分,就是将一张表的列给拆分成不同的表</p>
<p>缺点:主键出现冗余,需要join操作,还会让事务变得复杂</p>
<p>优点:列数据变少,查询的时候减少block数,减少io次数,简化表的结构,易于维护</p>
<h4 id="4-8-2-水平分区"><a href="#4-8-2-水平分区" class="headerlink" title="4.8.2 水平分区"></a>4.8.2 水平分区</h4><h4 id="4-8-3-分区后主键怎么定"><a href="#4-8-3-分区后主键怎么定" class="headerlink" title="4.8.3 分区后主键怎么定"></a>4.8.3 分区后主键怎么定</h4><ul>
<li><p>UUID:32位16进制数字,连字号分为五段,形式为8-4-4-4-12的36个字符.</p>
<p>优点:性能非常高,本地生成,没有网络消耗。</p>
<p>缺点:不能作为主键,太长了;不容易储存;信息不安全如基于MAC地址生成算法;无序性导致数据位置频繁变动,严重影响性能。</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">美团leaf</a></p>
</li>
</ul>
<h3 id="4-9-索引优化"><a href="#4-9-索引优化" class="headerlink" title="4.9 索引优化"></a>4.9 索引优化</h3><p>不要盲目的创建索引，索引利于查询，插入数据，删除的效率也会降低。</p>
<ol>
<li>利用联合索引</li>
<li>利用覆盖索引</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ljl150/p/12934071.html">最佳左前缀原则</a></li>
<li>建立联合查询的时候，区分度最高的字段放在最左边</li>
<li>建立索引的列不能为null,使用not null约束及默认值。</li>
</ol>
<h3 id="4-10-索引在什么情况下会失效"><a href="#4-10-索引在什么情况下会失效" class="headerlink" title="4.10 索引在什么情况下会失效"></a>4.10 索引在什么情况下会失效</h3><ol>
<li>当索引列的值了函数运算</li>
<li>强制类型转会导致全表扫描，如当varchar属性的列查询时没有加引号</li>
<li>前导模糊查询不能使用索引，“%a”这种形式</li>
<li>负条件不能使用索引，可以优化为in查询，负条件有!=,&lt;&gt;,not in,not exists等</li>
</ol>
<h3 id="4-11-什么时候需要建立索引"><a href="#4-11-什么时候需要建立索引" class="headerlink" title="4.11 什么时候需要建立索引"></a>4.11 什么时候需要建立索引</h3><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中排序的字段创建索引将大大提高排序的速度</li>
<li>查询中统计或者分组的字段</li>
</ol>
<h3 id="4-12-什么时候不需要创建索引"><a href="#4-12-什么时候不需要创建索引" class="headerlink" title="4.12 什么时候不需要创建索引"></a>4.12 什么时候不需要创建索引</h3><ol>
<li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件。</li>
<li>where条件利用不到的字段，不创建索引</li>
<li>表记录太少，不需要创建索引</li>
<li>经常增删改的表</li>
<li>数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。</li>
</ol>
<h3 id="4-13-MVCC（多版本并发控制）"><a href="#4-13-MVCC（多版本并发控制）" class="headerlink" title="4.13 MVCC（多版本并发控制）"></a>4.13 MVCC（多版本并发控制）</h3><p>优势：读不加锁，读写不冲突</p>
<p>MVCC下rr隔离级别下，innodb的select操作回按照下面两个条件检查每行记录：</p>
<ol>
<li>InnoDB只查找创建当前版本号早于会等于当前系统版本号的数据行，这样可以确保事务读取的行，要么是在事务之前已经存在的，要么是自身插入或者修改过的。</li>
<li>行的删除版本号要么未定义，要么大于当前系统版本号（当前事务开始之后删除的）。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ol>
<p><strong>实现原理：</strong>每一行有三个隐藏键</p>
<p>**DATA_TRX_ID:**记录最近更新这行记录的事务ID</p>
<p>**DATA_ROLL_PTR:**表示指向改行回滚段的指针，innodb便是通过这个指针找到之前版本的数据。改行记录上所有的旧版本，在undo中都通过链表的形式组织。</p>
<p>**DB_ROW_ID:**行标识（隐藏单调自增ID)，如果没有主键，innodb会自动生成一个隐藏主键，即此列。</p>
<p>**redo log:**将事务最新的数据存储起来</p>
<p>**undo log:**事务未提交之前，undo log保存未提交数据之前的数据版本，当读取某一行被其他事务操作时，可以从undo log中分析出该行之前记录的数据。实现事务的原子性，mvcc也是undo log实现的。</p>
<h3 id="4-14-Mysql的lru优化"><a href="#4-14-Mysql的lru优化" class="headerlink" title="4.14 Mysql的lru优化"></a>4.14 Mysql的lru优化</h3><p>mysql在读取数据的时候会将磁盘中的数据按照页的方式加载到bufferpool的缓冲区中,还维护了一个lru链表，链表的结点指向缓冲区的数据。当缓冲区存满的时候就需要替换掉不常用的数据，就用到了lru机制。但是由于不当在操作，可能会发生全表扫描。以及innodb存在预读的操作，即会将临近的页的数据提前加载到bufferpool中，这样可能会导致缓冲区存入一些不常用的数据，导致mysql性能下降。</p>
<p><strong>优化：</strong>bufferpool对数据进行了冷热分离，，将 LRU 链表分成两部分，一部分用来存放冷数据，也就是刚从磁盘读进来的数据，另一部分用来存放热点数据，也就是经常被访问到数据。冷区大小默认是37%。</p>
<p><strong>极致优化：</strong>当一个缓存页处于热数据区域的时候，我们去访问这个缓存页，这个时候我们真的有必要把它移动到热点数据区域的头部吗？</p>
<p>从代码的角度来看，将链表中的数据移动到头部，实际上就是修改元素的指针指向，这个操作是非常快的。但是为了安全起见，在修改链表的时候，我们需要对链表加上锁，否则容易出现并发问题。</p>
<p>当并发量大的时候，因为要加锁，会存在锁竞争，每次移动显然效率就会下降。因此 MySQL 针对这一点又做了优化，如果一个缓存页处于热数据区域，且在热数据区域的前 1/4 区域（注意是热数据区域的 1/4，不是整个链表的 1/4），那么当访问这个缓存页的时候，就不用把它移动到热数据区域的头部；如果缓存页处于热数据的后 3/4 区域，那么当访问这个缓存页的时候，会把它移动到热数据区域的头部</p>
<h3 id="4-15-explain字段"><a href="#4-15-explain字段" class="headerlink" title="4.15 explain字段"></a>4.15 explain字段</h3><p>type:查询类型</p>
<p>rows:查询的行数</p>
<p>extra:usingfilesort, using index, using tempory</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50998273/article/details/111938295">链接</a></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-可重入锁"><a href="#1-可重入锁" class="headerlink" title="1.可重入锁"></a>1.可重入锁</h3><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。ReentrantLock和synchronized都是可重入锁。当从磁盘读取数据页后，会先将数据页存放到 LRU 链表冷数据区的头部，如果这些缓存页在 1 秒之后被访问，那么就将缓存页移动到热数据区的头部；如果是 1 秒之内被访问，则不会移动，缓存页仍然处于冷数据区中。1 秒这个数值，是由参数 innodb_old_blocks_time 控制。</p>
<h3 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2.volatile"></a>2.volatile</h3><p>1.可见性</p>
<p>2.无法保证原子性，但是对于单个volatile变量的读写操作都是具有原子性的</p>
<p>3.禁止指令重排</p>
<h4 id="2-1-读写语义"><a href="#2-1-读写语义" class="headerlink" title="2.1 读写语义"></a>2.1 读写语义</h4><p>读语义：当读线程读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存读取共享变量。</p>
<p>写语义：当写线程写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>
<h4 id="2-2-语义实现原理"><a href="#2-2-语义实现原理" class="headerlink" title="2.2 语义实现原理"></a>2.2 语义实现原理</h4><ul>
<li>内存屏障：一组处理器指令，用于实现对内存操作的顺序限制</li>
<li>缓存行：CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。</li>
</ul>
<p>如何实现可见性：借助了CPU的lock指令，通过在写volatile的机械指令前加上lock前缀，使写volatile具有以下两个原则：1.写volatile时处理器会将缓存写回到主内存。2.一个处理器的缓存写回到内存会导致其他处理器的缓存失效。</p>
<p>如何实现禁止指令重排：加内存屏障</p>
<p>在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。<br>在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。<br>在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。<br>在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。</p>
<h3 id="3-上下文切换"><a href="#3-上下文切换" class="headerlink" title="3.上下文切换"></a>3.上下文切换</h3><p>多线程编程中，线程的个数大于cpu核心数，而cpu核心一次只能被一个线程使用，为了让这些线程都能够得到有效执行，cpu采用的适合为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这过程就是一次上下文切换。</p>
<h3 id="4-死锁条件"><a href="#4-死锁条件" class="headerlink" title="4.死锁条件"></a>4.死锁条件</h3><ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="5-为什么要调用start-方法然后执行run-，而不是直接调用run-方法。"><a href="#5-为什么要调用start-方法然后执行run-，而不是直接调用run-方法。" class="headerlink" title="5.为什么要调用start()方法然后执行run()，而不是直接调用run()方法。"></a>5.为什么要调用start()方法然后执行run()，而不是直接调用run()方法。</h3><p>new一个Thread,线程进入了新建状态。调用start()方法，会启动一个线程并使线程进入就绪状态，当分配到时间片之后就可以开始运行了。start()会执行线程相应的准备工作，然后自动执行run()方法的内容，这是真的正的多线程工作。但是如果直接调用run方法，把run()方法看成main()线程下的普通方法去执行，并不会再某个线程中执行它，这并不是多线程工作。</p>
<h3 id="6-synchronized"><a href="#6-synchronized" class="headerlink" title="6.synchronized"></a>6.synchronized</h3><p>构造方法不能使用synchronized修饰</p>
<p>修饰静态方法的时候，锁的是这个类，如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</p>
<p><strong>底层原理：</strong></p>
<p><strong>1.修饰代码块：</strong>synchronized同步语句块使用的是monitorenter和monitorexit指令，前者指向同步代码块开始的位置，后者表明同步代码块结束的位置。当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><strong>2.修饰方法：</strong>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</p>
<blockquote>
<p>两者本质都是对对象监视器monitor的获取。</p>
</blockquote>
<h3 id="7-为什么需要cpu高速缓冲器："><a href="#7-为什么需要cpu高速缓冲器：" class="headerlink" title="7.为什么需要cpu高速缓冲器："></a>7.为什么需要cpu高速缓冲器：</h3><p>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</p>
<p>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</p>
<h3 id="8-synchronized与volatile的区别"><a href="#8-synchronized与volatile的区别" class="headerlink" title="8.synchronized与volatile的区别"></a>8.synchronized与volatile的区别</h3><p>两者是互补的存在</p>
<p>volatile 关键字是线程同步的轻量级实现，所以<strong>volatile性能肯定比synchronized关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块</strong>。</p>
<p>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</p>
<p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</p>
<h3 id="9-ThreadLocal"><a href="#9-ThreadLocal" class="headerlink" title="9.ThreadLocal"></a>9.ThreadLocal</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fsmly/p/11020641.html">源码分析</a></p>
<h3 id="10-线程池"><a href="#10-线程池" class="headerlink" title="10.线程池"></a>10.线程池</h3><p><strong>优点：</strong></p>
<ol>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建以及销毁造成的消耗。</li>
<li>提高相应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h4 id="1-execute-方法与submit-方法的区别是什么"><a href="#1-execute-方法与submit-方法的区别是什么" class="headerlink" title="1.execute()方法与submit()方法的区别是什么"></a>1.execute()方法与submit()方法的区别是什么</h4><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</p>
<p>submit()方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过这个对象可以判断任务是否执行成功。并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h4 id="2-如何创建线程池"><a href="#2-如何创建线程池" class="headerlink" title="2.如何创建线程池"></a>2.如何创建线程池</h4><p>七大参数：</p>
<p>核心线程数</p>
<p>最大线程数</p>
<p>存活时间</p>
<p>时间单位</p>
<p>阻塞队列</p>
<p>线程工厂</p>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<p>拒绝策略：AbortPolicy:抛出RejectedExecutionException来拒绝新任务的处理；把任务抛出给运行自己的线程，会影响新任务的提交速度，影响程序的整体性能，还喜欢增加队列容量；直接丢弃新任务；丢弃最早的未处理的任务。</p>
<h3 id="11-Atomic原子类"><a href="#11-Atomic原子类" class="headerlink" title="11.Atomic原子类"></a>11.Atomic原子类</h3><p>基本数据类型</p>
<p>数组类型</p>
<p>引用类型</p>
<p>对象的属性修改类型</p>
<h3 id="12-AQS（AbstractQueuedSynchronizer"><a href="#12-AQS（AbstractQueuedSynchronizer" class="headerlink" title="12.AQS（AbstractQueuedSynchronizer)"></a>12.AQS（AbstractQueuedSynchronizer)</h3><p>在java.util.concurrent.locks包下,AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h3 id="13-如何解决CAS中的ABA问题"><a href="#13-如何解决CAS中的ABA问题" class="headerlink" title="13.如何解决CAS中的ABA问题"></a>13.如何解决CAS中的ABA问题</h3><p>CAS具体包括三个参数：<strong>当前内存值V、旧的预期值A</strong>、<strong>即将更新的值B</strong>，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>
<p>加上本版号，如AtomicStampedReference的compareAndSet函数compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)。</p>
<p>（1）第一个参数expectedReference：表示预期值。</p>
<p>（2）第二个参数newReference：表示要更新的值。</p>
<p>（3）第三个参数expectedStamp：表示预期的时间戳。</p>
<p>（4）第四个参数newStamp：表示要更新的时间戳。</p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1-1-String为什么不可变"><a href="#1-1-String为什么不可变" class="headerlink" title="1.1 String为什么不可变"></a>1.1 String为什么不可变</h3><p>被final修饰了，是个字符数组</p>
<h3 id="1-2-接口与抽象类有什么区别"><a href="#1-2-接口与抽象类有什么区别" class="headerlink" title="1.2 接口与抽象类有什么区别"></a>1.2 接口与抽象类有什么区别</h3><p>1.接口的默认public ，抽象类内部可以有非抽象方法</p>
<p>2.接口中只能有static,final变量，而抽象类则不一定</p>
<p>3.一个类可以实现多个接口，但只能实现一个抽象类。接口本身可以多继承接口。</p>
<p>接口的方法默认修饰符是public,抽象方法可以是public,protected和default</p>
<p>4.从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口时对行为的抽象，是一种行为的规范</p>
<blockquote>
<p>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。<br>jdk 8 的时候接口可以有默认方法和静态方法功能。<br>Jdk 9 在接口中引入了私有方法和私有静态方法。</p>
</blockquote>
<h3 id="1-3-哈希碰撞是什么"><a href="#1-3-哈希碰撞是什么" class="headerlink" title="1.3 哈希碰撞是什么"></a>1.3 哈希碰撞是什么</h3><h3 id="1-4-如何减少哈希碰撞"><a href="#1-4-如何减少哈希碰撞" class="headerlink" title="1.4 如何减少哈希碰撞"></a>1.4 如何减少哈希碰撞</h3><p><strong>1.开放地址法：</strong>根据一个公式再散列。</p>
<p><strong>2.再哈哈希法：</strong>比如按照首字符哈希发生了冲入，可以按照首字母第二位进行哈希，再冲突，按照第三位进行哈希。</p>
<p><strong>3.链地址法：</strong>比如如java中的Hashmap.</p>
<p><strong>4.建立一个公共溢出区：</strong>用以存储发生冲突的记录</p>
<p>拉链法优点：</p>
<p>1.处理冲突简单，且无堆积现象。</p>
<p>2.拉链法中各链表上的结点空间是动态申请的，故他更适合于造表前无法确定表的长度的情况。</p>
<p>3.开放地址法为减少冲突，要求加载因子较小，当结点规模较大的时候会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间。</p>
<p>4.在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</p>
<h3 id="1-5-常见的异常"><a href="#1-5-常见的异常" class="headerlink" title="1.5 常见的异常"></a>1.5 常见的异常</h3><p>受检异常:IOException,ClassNotFoundException</p>
<p>不受检异常：NullPointerException,NumberFormatException,ArrayIndexOutofBoundsException,</p>
<p>ClassCastException,ArithmeticException，ConcurrentModificationException.</p>
<h3 id="1-6-final语句"><a href="#1-6-final语句" class="headerlink" title="1.6 final语句"></a>1.6 final语句</h3><p>如果try与finally中都有return,final的返回值会覆盖try中的返回值</p>
<p>finally为什么一定会执行？</p>
<p>编译器在编译Java代码的时候，会把finally代码块里的内容，复制一份，分别放在try块和catch块里所有正常执行路径以及异常执行路径的出口中</p>
<h3 id="1-7-BIO-NIO-AIO区别"><a href="#1-7-BIO-NIO-AIO区别" class="headerlink" title="1.7 BIO,NIO,AIO区别"></a>1.7 BIO,NIO,AIO区别</h3><p>**BIO:**同步阻塞I/O模式，数据的读取和写入必须阻塞在一个线程内等待其完成，简单，但是无法适应高并发。</p>
<p>**NIO:**同步非阻塞的I/O模型，java1.4引入了NIO框架，提供了Channel,Selector,Buffer等抽象。</p>
<p><strong>AIO：</strong>异步非阻塞的I/O模型。</p>
<p><em>进程中的IO调用步骤大致可以分为以下四步：</em></p>
<p><em>进程向操作系统请求数据 ;</em></p>
<p><em>操作系统把外部数据加载到内核的缓冲区中;</em></p>
<p><em>操作系统把内核的缓冲区拷贝到进程的缓冲区 ;</em></p>
<p><em>进程获得数据完成自己的功能 ;</em></p>
<p><em>当操作系统在把外部数据放到进程缓冲区的这段时间（即上述的第二，三步），如果应用进程是挂起等待的，那么就是同步IO，反之，就是异步IO，也就是AIO 。</em></p>
<p><strong>为什么epoll比poll与select效率高：</strong></p>
<p>1.减少了用户态和内核态之间的文件描述符拷贝 </p>
<p>2.减少了对就绪文件描述符的遍历</p>
<h3 id="1-8-CopyOnWriteArraylist"><a href="#1-8-CopyOnWriteArraylist" class="headerlink" title="1.8 CopyOnWriteArraylist"></a>1.8 CopyOnWriteArraylist</h3><p>写时加锁并copy数组并且大小加一</p>
<h3 id="1-9-实例化对象的方法"><a href="#1-9-实例化对象的方法" class="headerlink" title="1.9 实例化对象的方法"></a>1.9 实例化对象的方法</h3><ol>
<li>new创建对象</li>
<li>工厂方法返回对象，如String str=String.value(23);</li>
<li>反射手段 如：Object obj =Class.forName(“java.lang.Object”).newInstance();</li>
<li>调用对象的clone()方法</li>
<li>通过I/O流，如利用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ol>
<h3 id="1-10-JDK8新特性"><a href="#1-10-JDK8新特性" class="headerlink" title="1.10 JDK8新特性"></a>1.10 JDK8新特性</h3><ol>
<li>代码更少（增加了新语法：Lambda 表达式）</li>
<li>强大的 Stream API（集合数据的操作）</li>
<li>最大化的减少空指针 异常：Optional 类 的使用</li>
<li>接口的新特性</li>
<li>注解的新特性</li>
<li>集合的底层 源码实现</li>
<li>新日期时间的 api</li>
</ol>
<h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><h3 id="1-ArrayList与LinkedListb比较"><a href="#1-ArrayList与LinkedListb比较" class="headerlink" title="1.ArrayList与LinkedListb比较"></a>1.ArrayList与LinkedListb比较</h3><ol>
<li>前者是Object数组，后者是双向链表</li>
<li>前者支持高效的随即元素访问</li>
<li>插入删除元素区别（自己说）</li>
<li>内存占用，前者一般会预留一些数组空间，后者需要存储前后的结点位置数据</li>
</ol>
<h3 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="2.ArrayList"></a>2.ArrayList</h3><ol>
<li>jdk7中创建便new空间10，jdk8添加元素的时候才会给数组分配空间。</li>
</ol>
<h3 id="3-HashMap与Hashtable"><a href="#3-HashMap与Hashtable" class="headerlink" title="3.HashMap与Hashtable"></a>3.HashMap与Hashtable</h3><ol>
<li>前者非线程安全，后者安全</li>
<li>前者效率高</li>
<li>前者支持Null key，会放在表头</li>
<li>前者初始大小为16，负载因子为0.75，每次扩容乘以二，但是必须为2的次幂。后者初始11，每次 扩容变成2n+1,有参构造设置多少就是多少。</li>
<li>前者当链表的长度大于8(先检查当前数组的产固定，如果当前数组商都小于64，会先进行扩容，而不是转换为红黑树)时，会转换成红黑树。</li>
</ol>
<h3 id="4-HashMap底层实现"><a href="#4-HashMap底层实现" class="headerlink" title="4.HashMap底层实现"></a>4.HashMap底层实现</h3><p>HashMap只锁住了当前链表或红黑树的首结点，只要不发生哈希冲突，就不会产生并发，效率又提升N倍</p>
<p>哈希函数（扰动函数）：hashcode的高16位与低16位进行异或操作再去进行取模操作。</p>
<h3 id="5-jdk8的优化"><a href="#5-jdk8的优化" class="headerlink" title="5.jdk8的优化"></a>5.jdk8的优化</h3><ol>
<li>7没有红黑树结构</li>
<li>链表的插入从头插法改成了尾插法，先扩容再插入改成了先插入再扩容</li>
<li>扩容的时候7需要对原数组的元素进行从新hash定位再新的数组位置，8采用更简单的判断逻辑，位置不变或索引+旧容量大小。</li>
<li>扰动函数，7有四次移位和异或，8只有一次。</li>
<li>多线程情况下1.7会发生死循环，数据丢失，数据覆盖的问题，1.8会有数据覆盖的问题，还有++size会造成多线程同时扩容的问题。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42515631/article/details/112096432?utm_source=app&app_version=4.5.5">HashMap</a></p>
<h4 id="6-HashMap为什么不适用avl树而使用红黑树"><a href="#6-HashMap为什么不适用avl树而使用红黑树" class="headerlink" title="6.HashMap为什么不适用avl树而使用红黑树"></a>6.HashMap为什么不适用avl树而使用红黑树</h4><ol>
<li>AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。</li>
<li>红黑树更适合插入修改密集型任务</li>
<li>通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。</li>
</ol>
<h4 id="7-红黑树结构"><a href="#7-红黑树结构" class="headerlink" title="7.红黑树结构"></a>7.红黑树结构</h4><p>根节点为黑</p>
<p>叶子子节点为黑 且无数据</p>
<p>红节点的子节点为黑</p>
<p>任意一点到某一叶子节点的路径中黑节点数量相同</p>
<p>根节点到任一叶子结点的不同路径长度不超过两倍</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h3><p>操作系通是管理计算机硬件与软件资源的应用程序，他的存在屏蔽了硬件层的复杂性，操作系统的内核是操作系统的核心部分，负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。是连接应用程序与硬件的桥梁，决定着系统的性能和稳定性。</p>
<h3 id="1-2-系统调用"><a href="#1-2-系统调用" class="headerlink" title="1.2 系统调用"></a>1.2 系统调用</h3><p>进程在系统上运行的两个级别：</p>
<p>用户态：用户态运行的程序可以直接读取用户应用程序的数据。</p>
<p>系统态:进程可=几乎可以访问计算机的所有资源不受限制。</p>
<p>系统调用分为：进程通信，进程控制，内存管理，文件管理，设备管理。</p>
<h3 id="1-3-进程与线程"><a href="#1-3-进程与线程" class="headerlink" title="1.3 进程与线程"></a>1.3 进程与线程</h3><p>进程就是一个应用程序，而一个进程里面包括可能不止一个线程，如我们运行的java程序，总的来说是一个进程，但是在执行的过程中有着Main主线程，gc垃圾回收线程与异常处理机制等。进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位。线程是cpu调度和分派的基本单位，它可以与同属于一个进程的其他线程共享进程所有的的全部资源。</p>
<h3 id="1-4-进程间的通信方式"><a href="#1-4-进程间的通信方式" class="headerlink" title="1.4 进程间的通信方式"></a>1.4 进程间的通信方式</h3><ol>
<li><p>管道/名管道：用于有情缘关系的父子进程或者兄弟进程之间的通信，存在于内存之中。</p>
</li>
<li><p>命名管道：以磁盘文件的方式存在，可以实现本机任意两个进程通信。半双工。</p>
</li>
<li><p>信号：一种复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
<li><p>消息队列：全双工，存放在内核中，只有在内核重启或者显示删除消息队列的时候，该消息队列才会被删除。一般先进先出，但是可以按照消息读取的类型读取，比FIFO更有优势，而且客服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺陷。 消息队列可以认为是一个全局的一个链表，链表节点钟存放着数据报的类型和内容，有消息队列的标识符进行标记</p>
</li>
<li><p>信号量(Semaphores):信号量是一个计数器，用于多进程对于共享资源的访问，同步进程的作用。</p>
</li>
<li><p>共享内存：多个进程共享一块内存。</p>
</li>
<li><p>套接字：用于客户端与服务端之间的网络通信。</p>
<p>其中共享内存的效率是最高的，将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以。</p>
</li>
</ol>
<h3 id="1-5-线程之间同步方式"><a href="#1-5-线程之间同步方式" class="headerlink" title="1.5 线程之间同步方式"></a>1.5 线程之间同步方式</h3><p>1.互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，互斥对象只有一个，可以保证公共资源不会被多个线程同时访问。sychronized与lock都是这种机制。</p>
<p>2.信号量：允许多个线程访问同一资源，但是需要控制最大的线程数量。</p>
<p>3.事件：wait/notify:通过通知的方式来保持多线程同步。</p>
<h3 id="1-6-进程的调度算法"><a href="#1-6-进程的调度算法" class="headerlink" title="1.6 进程的调度算法"></a>1.6 进程的调度算法</h3><ol>
<li>先到先服务调度算法（FCFS）：从就绪队列中选择最先进入该队列的进程为之分配资源，使它立即执行一直到执行完成或者发生事件发生阻塞放弃占用CPU再重新调度。</li>
<li>短作业优先调度算法（SJF）：从就绪队列选择一个估计运行事件最短的进程为之分配资源，使它立即执行一直到执行完成或者发生事件发生阻塞放弃占用CPU再重新调度。</li>
<li>时间片轮转调度算法：最古老，最简单公平，使用最广的算法，为每个进程分配一个时间段，称作时间片，即该进程可以运行的时间。</li>
<li>多级反馈队列调度算法：既能使高优先级的作业得到响应又能使短作业进程迅速完成，克服了上面调度算法的一些局限性。</li>
<li>优先级调度算法：根据内存要求，时间要求或者其他资源要求为每个进程分配优先级，优先级高的进程先执行。      </li>
</ol>
<h3 id="1-7-内存管理机制"><a href="#1-7-内存管理机制" class="headerlink" title="1.7 内存管理机制"></a>1.7 内存管理机制</h3><p>连续分配管理机制：为用户程序分配一个连续的内存空间，如块式管理</p>
<p>非连续分配管理机制：页式管理，段式管理，段页式管理</p>
<p>1.块式管理：远古时期，将内存分为固定的几个大块，每块中包含一个进程，如果程序运行需要内存的话，就分给他一块，如果程序运行只需要很小的一块内存，就会导致很多内存浪费，浪费的内存被成为碎片。</p>
<p>2.页式管理：把主内存分为很多页，页较小，相对于块式管理的划分力度更大，提高了内存使用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</p>
<p>3.段式管理：页式管理提高了内存使用率，但是页是没有实际意义的。段式管理。每一段的空间比页更小，而且具有意义，每个段定义了一组逻辑信息，例如有主程序段，子程序段，数据段和栈段等。通过段表对应逻辑地址和物理地址。</p>
<p>4.段页式管理机制：结合了段式管理和页式管理的优点，主内存先分成很多段，每一段又分成很多页，段与段以及段的内部都是离散的。</p>
<h3 id="1-8-分页机制与分段机制的区别"><a href="#1-8-分页机制与分段机制的区别" class="headerlink" title="1.8 分页机制与分段机制的区别"></a>1.8 分页机制与分段机制的区别</h3><p>同：都是为了提高内存使用率，减少内存碎片；都是离散存储的。</p>
<p>异：页的大小是固定的，又操作系统决定，段的大小不固定，取决于当前运行的程序。分页只是为了满足操作系统的内存管理需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好的满足用户的需求。</p>
<h3 id="1-9-页表"><a href="#1-9-页表" class="headerlink" title="1.9 页表"></a>1.9 页表</h3><p>页表是放在内存中一个数据结构，存放逻辑地址和物理地址的映射关系。</p>
<p>页表机制缺陷：当虚拟地址空间很大，页面也会很大，会影响内存的性能。为了避免把全部页表放在内存中引入了多级页表，但损失了时间性能。</p>
<h3 id="1-10-快表"><a href="#1-10-快表" class="headerlink" title="1.10 快表"></a>1.10 快表</h3><p>理解为一种特殊的高速缓冲器，内容是一页的全部或者一部分内容，作用与页表相似，但是提高了访问效率。页表做地址转换的话读写内存数据需要访问两次主存，有了块表，只需要访问一次高速缓冲器，一次主存，提高了CPU寻址和指令执行的速度。</p>
<h3 id="1-11-CPU寻址"><a href="#1-11-CPU寻址" class="headerlink" title="1.11 CPU寻址"></a>1.11 CPU寻址</h3><p>虚拟地址转换为物理地址的过程，利用CPU中的MMU（内存管理单元）的硬件。</p>
<h3 id="1-12-为什么需要虚拟地址"><a href="#1-12-为什么需要虚拟地址" class="headerlink" title="1.12 为什么需要虚拟地址"></a>1.12 为什么需要虚拟地址</h3><p>没用虚拟地址的话，程序都是直接访问操作物理地址，可能会对操作系统造成伤害以及给同时运行多个程序造成困难。</p>
<p>优势：1.程序可以使用相邻的虚拟内存地址来访问物理内存中不相邻的的大的内存缓冲区。</p>
<p>​            2.程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区</p>
<p>​            3.不同进程之间的虚拟地址彼此隔离。一个进程中的代码无法更改正有另一个进程或操作系统使用的物理内存。</p>
<h3 id="1-13-什么是虚拟内存"><a href="#1-13-什么是虚拟内存" class="headerlink" title="1.13 什么是虚拟内存"></a>1.13 什么是虚拟内存</h3><p>举一个例子，软件占用内存大于物理内存却可以运行，为每个进程提供了一个一致的，私有的地址空间，让每个进程有了一种自己独享主存的错觉。</p>
<p>虚拟内存是计算机系统内存管理的一种技术，定义了一个连续的虚拟地址空间，把内存扩展到硬盘空间。</p>
<h3 id="1-14-局部性原理"><a href="#1-14-局部性原理" class="headerlink" title="1.14 局部性原理"></a>1.14 局部性原理</h3><p>正因为有着局部性原理，才能够装入部分程序到内存就开始运行。</p>
<p>1.时间局部性：如果程序某条指令一旦被执行，不久之后就可以再次执行；数据被访问过，一段时间之后就会再次被访问，原因就是程序中存在大量的循环操作。</p>
<p>2.空间局部性：一旦程序访问了某个存储单元，不久之后，其附近的单元也将会被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序春芳，顺序执行，数据一般也是以向量，链表，数组，表等形式簇聚存储的。</p>
<p>时间局部性是通过近来使用的指令和数据保存到高速缓冲区中，并使用高速缓存的层次结构实现，空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存其实就是建立了内存-外存的两级存储器结构，利用局部性原理实现高速缓存。</p>
<h3 id="1-15-虚拟内存的技术实现"><a href="#1-15-虚拟内存的技术实现" class="headerlink" title="1.15 虚拟内存的技术实现"></a>1.15 虚拟内存的技术实现</h3><p>建立在离散分配的内存管理方式的基础上。</p>
<p>实现有三种方式：</p>
<p><strong>1.请求分页存储管理：</strong>建立在分页管理上，为了支持虚拟内存而增加了请求调页功能和页面置换功能。在作业开始运行之前，仅装入当前需要的部分段即可运行，在作业过程中如果遇到了当前要访问的页面不在主存则有处理器通知操作系统按照相应的页面置换算法将相应的页面调到主存，同时也可以将暂时不用的页置换到外存中。</p>
<p><strong>2.请求分段存储管理</strong>：在段式管理的基础上，增加了请求调段和分段置换功能，与请求分页存储管理类似，载入部分段便可以运行，中途遇到需要但是不存在内存中的段，便要求调入。当内存满了，又需要加入新的段时，根据置换功能适当调出某个段，以便腾出空间装入新的段。</p>
<p><strong>3.请求段页式存储管理</strong></p>
<h3 id="1-16-这些管理方式会遇到什么问题"><a href="#1-16-这些管理方式会遇到什么问题" class="headerlink" title="1.16 这些管理方式会遇到什么问题"></a>1.16 这些管理方式会遇到什么问题</h3><p><strong>1.缺页中断：</strong>如果需要的数据不在内存中，就是却页或缺段，处理器告诉操作系统将相应的页或段加载到内存中才能继续运行。</p>
<p><strong>2.cpu寻址：</strong>逻辑地址到物理地址的变换。</p>
<h3 id="1-17页面置换算法"><a href="#1-17页面置换算法" class="headerlink" title="1.17页面置换算法"></a>1.17页面置换算法</h3><p>当缺页中断的时候，内存中没有空闲的页面，此时必须选择一个页移除内存，将需要的页置换回来。</p>
<p><strong>OPT置换算法（最佳页面置换算法）：</strong>淘汰的页面是置换永不使用的，或者在长时间内不再被访问的页面，可以保证最低的缺页率。但是人们无法预知什么页面在之后的时间内不会被使用，所以该算法无法实现，一般作为衡量其他置换算法的方法。</p>
<p><strong>FIFO页面置换算法（先进先出置换算法）：</strong>淘汰最先进入内存的页面。</p>
<p><strong>LRU页面置换算法：</strong>赋予页面一个访问字段，表示该页面上次被访问以来经历的时间，淘汰时间最大的那个即最长时间没用的那个页面。</p>
<p><strong>LFU页面置换算法：</strong>淘汰使用频率最少的页面。</p>
<h3 id="1-18-上下文是什么"><a href="#1-18-上下文是什么" class="headerlink" title="1.18 上下文是什么"></a>1.18 上下文是什么</h3><h3 id="1-19-进程的三大状态"><a href="#1-19-进程的三大状态" class="headerlink" title="1.19 进程的三大状态"></a>1.19 进程的三大状态</h3><p>就绪状态：进程已获得除处理器外的所需资源，只是在等待分配处理器资源，只要分配了处理器进程就可执行。准备就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列。当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。</p>
<p>运行状态：进程占用处理器资源，处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以执行时（如所有进程都在阻塞状态），系统通常会自动执行系统的空闲进程。</p>
<p>阻塞状态，英文称Blocked，系统由于进程等待某种条件（如I/O操作或进程同步），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，该进程也无法进行运行。</p>
<p>1）用户态切换到内核态的3种方式<br>a.系统调用<br>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。</p>
<p>而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p>
<p>b.异常<br>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此<br>异常的内核相关程序中，也就到了内核态，比如缺页异常。<br>c.外围设备的中断<br>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令<br>转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有<br>用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<h3 id="1-20-select-poll-epoll模型"><a href="#1-20-select-poll-epoll模型" class="headerlink" title="1.20 select,poll epoll模型"></a>1.20 select,poll epoll模型</h3><p>单线程select只能监视1024个文件描述符，可以更改，但是轮询方式，数量越大效率越低</p>
<p>select拷贝大量句柄数据放在数组中，应用程序需要遍历才能知道那些句柄发生了事件。</p>
<p>poll用的是链表，也是轮询。</p>
<p>epoll有着回调函数，实现机制会创建一个epoll对象，对象中维护者一个红黑树以及双向链表,红黑树保存着所有的事件，链表中则是维护了发生了事件，epoll中的事件都会与设备(网卡)驱动程序建立回调关系，当相应的事件发生时会调用这个回调方法，它会将发生的事件添加到rdlist双链表中。当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>
<p><strong>文件描述符：</strong>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<h3 id="1-21-IO模型-链接"><a href="#1-21-IO模型-链接" class="headerlink" title="1.21 IO模型 链接"></a>1.21 IO模型 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ligupeng7929/article/details/93672312">链接</a></h3><p>同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！</p>
<p>同步非阻塞IO：在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。JAVA的NIO就属于同步非阻塞IO。</p>
<p>异步阻塞IO：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！</p>
<p>异步非阻塞IO：在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。Java AIO属于这种异步非阻塞模型。</p>
<h3 id="1-22-非阻塞与异步"><a href="#1-22-非阻塞与异步" class="headerlink" title="1.22 非阻塞与异步"></a>1.22 非阻塞与异步</h3><p>在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。</p>
<p>–而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qzqanzc/article/details/81008598">内存模型</a></p>
<h3 id="1-23-僵尸进程"><a href="#1-23-僵尸进程" class="headerlink" title="1.23 僵尸进程"></a>1.23 僵尸进程</h3><p>子进程先于父进程结束，但是子进程的PCB并没有被父进程释放（每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息：进程id,进程状态，进程切换需要保存和恢复的一些寄存器，虚拟地址空间的信息，文件描述符等）。在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。</p>
<p>解决方式：</p>
<ol>
<li>关闭子进程，子进程就会被init进程托管关闭</li>
<li>信号，即wait()/waitpid()</li>
</ol>
<h3 id="1-25-kill"><a href="#1-25-kill" class="headerlink" title="1.25 kill"></a>1.25 kill</h3><ol>
<li><p>kill-15：程序立刻停止；当程序释放相应资源后再停止；程序可能仍然继续运行大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应，我在使用wkhtmltopdf转pdf的项目中遇到这现象），也就是说，SIGTERM多半是会被阻塞的。</p>
</li>
<li><p>kill-9：直接杀死进程，exit(0);</p>
<p>它没有给进程留下善后的机会：</p>
<ol>
<li><p>关闭socket链接</p>
</li>
<li><p>清理临时文件</p>
</li>
<li><p>将自己将要被销毁的消息通知给子进程</p>
</li>
<li><p>重置自己的终止状态</p>
</li>
</ol>
</li>
</ol>
<h3 id="1-24-孤儿进程"><a href="#1-24-孤儿进程" class="headerlink" title="1.24 孤儿进程"></a>1.24 孤儿进程</h3><p>父进程先于子进程结束，孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qzqanzc/article/details/81008598">内存模型</a></p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p>唯一一个不会出现OutOfMemoryError的的内存区域，生命周期随着线程</p>
<p>1.字节码解释器通过改变程序计数器的来依此读取指令，从而实现代码的流程控制，如顺序执行，选择，循环，异常处理。</p>
<p>2.多线程情况下用于记录当前线程所执行的位置，从而当线程被切换回来的时候就能够知道该线程上次运行到哪了。</p>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h3><p>java虚拟机栈是由一个个栈帧组成，而每个栈帧中都有：局部变量表；操作数栈，动态链接（指向运行时常量池的方法引用），方法出口信息。</p>
<p>1.如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
<p>2.如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。HotSpot虚拟机不支持栈动态扩展。</p>
<p>一个方法如果无限递归，那么迟早会抛出StackOverflowError异常</p>
<p>不断创建新的线程就会导致OutOfMemoryError，应为每个进程的内存是一定的，分给每个线程的内存也是一定的。</p>
<h3 id="3-方法区"><a href="#3-方法区" class="headerlink" title="3.方法区"></a>3.方法区</h3><p>永久代这个玩意其实是HotSpot虚拟机方法区的一种实现，其他虚拟机没用这个永久代说法</p>
<p>为什么要换成元空间：1.元空间使用的是直接内存，如果没有指定元空间的最大大小，那元空间就会动态调整大小，受限于本机内存，虽然还是可能会溢出，但是出现的机率比以前小。2.元空间存放的是类的元数据，这样加载多少类的元数据就不MaxPermSize控制了，而由系统实际可用空间来控制，这样就能加载更多的类了。3.Oracle 可能会将HotSpot 与 JRockit 合二为一</p>
<h3 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4.运行时常量池"></a>4.运行时常量池</h3><ol>
<li>Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有常量池表（编译期生成的各种字面量和符号引用）</li>
<li>1.7之前运行时常量池于与字符串常量池都在方法区中。</li>
<li>1.7将字符串常量池移到了堆中</li>
<li>字符串常量池还是在堆中，运行时常量池在方法区，hotspot此时将方法区实现为元空间。</li>
</ol>
<p>常量池中的常量不仅仅是在编译期产生，而且运行时也会产生，如基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）。</p>
<p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段名称和描述符</li>
<li>方法名称和描述符</li>
</ul>
<p>字符串常量池也是存的字符串对象的引用</p>
<p>符号引用：由于在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，所以如果你在一个类中引用了另一个类，那么你完全无法知道他的内存地址，那怎么办，我们只能用他的类名作为符号引用，在类加载完后用这个符号引用去获取他的内存地址。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaotian15/p/6971353.html">常量池</a></p>
<h3 id="5-java对象创建的过程"><a href="#5-java对象创建的过程" class="headerlink" title="5.java对象创建的过程"></a>5.java对象创建的过程</h3><p><strong>1. 类加载检查：</strong>虚拟机遇到一条new指令的时候，先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过，解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p><strong>2. 分配内存：</strong>类加载检查过后，便需要给新生的对象分配内存，类加载过后便能知道对象所需的内存大小，给对象分配内存就是将堆中的一块内存划分出来，分配的方式有“指针碰撞”和“空闲列表”，选择哪种方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><strong>指针碰撞：</strong></p>
<p>适用场合：堆内存规整（即没有内存碎片）的情况下</p>
<p>原理：用过的内存整合到一边，没有用过的内存放在另一边，中间有一个分界值指针，只需要向着没有用过的内存方向将该指针移动对象大小的内存位置即可。</p>
<p>GC收集器：Serial,ParNew</p>
<p><strong>空闲列表：</strong></p>
<p>适用场合：堆内存不规整的情况下</p>
<p>原理：虚拟机会维护一个列表，该列表中会记录那些内存块是可用的，在分配的时候，找一块足够大的内存划分给对象实例，最后更新列表记录。</p>
<p>GC收集器：CMS</p>
<p><strong>内存分配并发问题：</strong></p>
<ul>
<li>CAS+失败重试</li>
<li>TLAB：为每个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首相在TLAB分配，当对象大于<a target="_blank" rel="noopener" href="https://blog.csdn.net/hfer/article/details/106077631">TLAB</a>中的剩余内存或*TLAB内存已经用尽时，再采用上述的CAS内存进行分配。</li>
</ul>
<p><strong>3.初始化零值</strong></p>
<p>内存分配之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步保证了对象的实例字段在Java代码中可以不赋初始值就可以直接使用，程序能访问到这些字段的数据类型对应的零值。</p>
<p><strong>4.设置对象头</strong></p>
<p>初始化零值之后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。这些信息放在对象头中。另外，根据虚拟机当前的运行状态的不同，如是否启用<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36eedeb3f912">偏向锁</a>等，对象头会有不同的设置方式。</p>
<p><strong>5.执行init方法</strong></p>
<p>之前的工作都完成之后，一个新的对象已经产生了，但是init方法还没有执行，所有字段都还位零。所以还需要执行<init>f方法。</p>
<h3 id="6-对象访问有哪两种方式"><a href="#6-对象访问有哪两种方式" class="headerlink" title="6.对象访问有哪两种方式"></a>6.对象访问有哪两种方式</h3><p>java程序通过栈上的reference数据来操作堆上的具体对象。</p>
<p><strong>1.句柄：</strong>java堆会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中存储了对象的实例数据与类型数据各自的具体地址。</p>
<p><strong>2.直接指针：</strong>这样对象的布局中就需要考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象的地址。</p>
<h3 id="7-JVM内存分配与回收"><a href="#7-JVM内存分配与回收" class="headerlink" title="7.JVM内存分配与回收"></a>7.JVM内存分配与回收</h3><p>一般分配方式：对优先在eden区分配，大对象直接进入老年代，长期存活的对象将进入老年代。</p>
<p>为何大对象（需要大量连续内存空间的对象，如字符串，数组）需要直接进入老年代呢？</p>
<p>为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h3 id="8-如何判断对象已经死亡"><a href="#8-如何判断对象已经死亡" class="headerlink" title="8.如何判断对象已经死亡"></a>8.如何判断对象已经死亡</h3><p><strong>引用计数法：</strong>给对象中添加一个引用计数器，当有一个引用指向他，计数器加一，当引用失效，计数器减一，当计数器为零的时对接就死亡了</p>
<p><strong>可达性分析算法：</strong>通过一系列称为“GC Roots”的对象作为起点，从这些结点向下搜索，结点所走过的路径称为引用链，当一个对象到GC roots没有任何引用链的话，该对象死亡。</p>
<h3 id="9-什么对象可以作为GC-Roots"><a href="#9-什么对象可以作为GC-Roots" class="headerlink" title="9.什么对象可以作为GC Roots"></a>9.什么对象可以作为GC Roots</h3><ol>
<li>虚拟机栈中的引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用对象</li>
<li>本地方法栈中JNI引用对象</li>
</ol>
<h3 id="10-强，软，弱，虚引用"><a href="#10-强，软，弱，虚引用" class="headerlink" title="10.强，软，弱，虚引用"></a>10.强，软，弱，虚引用</h3><h3 id="11-如何判断一个类是无用的"><a href="#11-如何判断一个类是无用的" class="headerlink" title="11.如何判断一个类是无用的"></a>11.如何判断一个类是无用的</h3><ul>
<li>该类所以的实例都已经被回收，也就是java堆中不存在该类的任何实例方法。</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>满足三个条件也不一定会被回收。</p>
<h3 id="12-垃圾收集算法"><a href="#12-垃圾收集算法" class="headerlink" title="12.垃圾收集算法"></a>12.垃圾收集算法</h3><p><strong>标记-清除算法：</strong></p>
<p><strong>复制算法：</strong></p>
<p><strong>标记-整理算法：</strong></p>
<p>所有都是分代收集算法</p>
<p>为什么要分为新生代与老年代？<br>为了提升GC效率</p>
<h3 id="13-垃圾收集器"><a href="#13-垃圾收集器" class="headerlink" title="13.垃圾收集器"></a>13.垃圾收集器</h3><p><strong>1.Serial收集器</strong></p>
<p>串行收集器，一条线程收集垃圾，而且收集过程必须”stop the world”,暂停其他所有线程。简单高效 ，没有线程交互的开销适合Client模式下的虚拟机。</p>
<p>新生代复制算法，老年代标记-整理算法</p>
<p><strong>2.ParNew收集器</strong></p>
<p>Serial收集器的多线程版本，适合Server模式下的虚拟机的首要选择，只有他能与CMS收集器配合工作。</p>
<p>新生代复制算法，老年代标记-整理算法</p>
<p><strong>3.Parallel Scavenge收集器：</strong>jdk8默认收集器</p>
<p>关注的是吞吐量（高效的利用CPU)。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。吞吐量就是cpu中用于运行用户代码的时间与cpu中消耗时间的比值。</p>
<p>多线程，也会stw。</p>
<p><strong>4.Serial Old收集器</strong></p>
<p>Serial收集器的老年代版本，单线程。</p>
<p>用途：jdk5之前与Parallel Scavenge收集器搭配使用；作为CMS收集器的后备方案。</p>
<p><strong>5.Parallel Old收集器</strong></p>
<p>Parallel Scavenge收集器的老年代版本</p>
<p><strong>6.CMS(concurrent mark sweep)收集器</strong></p>
<p>最短回收停顿，这种意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>步骤：</p>
<ol>
<li>初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快。</li>
<li>并发标记，无法保证可达性分析的实时性。</li>
<li>重新标记：停止用户线程，为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段时间比初始标记时间稍长，比并发标记时间短。</li>
<li>并发清除</li>
</ol>
<p>缺点：1. 对cpu资源敏感；2.无法处理浮动垃圾；3.它使用的标记-清除算法会有大量空间碎片产生。</p>
<blockquote>
<p>浮动垃圾：并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理。这些垃圾有个专业名词：浮动垃圾。</p>
</blockquote>
<p><strong>7.G1（Garbage-First)垃圾收集器</strong></p>
<p>针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量的性能特征。</p>
<p>特点：</p>
<ol>
<li>并行与并发：充分利用CPU,多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stw的停顿时间。部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li>分代收集：</li>
<li>空间整合：与CMS不同，整体上来看是基于“标记整理”算法实现的，从局部上来看是基于“复制”算法实现的。</li>
<li>可预测的停顿：可以建立可预测的停顿时间模型，能让使用者明确在指定一个长度为M毫秒的时间片段内。</li>
</ol>
<p>步骤：初始标记，并发标记，最终标记，筛选回收。</p>
<p>G1收集器后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。</p>
<p><strong>8.ZGC收集器</strong></p>
<h3 id="14-类加载过程"><a href="#14-类加载过程" class="headerlink" title="14.类加载过程"></a>14.类加载过程</h3><p>加载、验证、准备、解析、初始化、使用和卸载7个阶段</p>
<p>装载：查找和导入Class文件；</p>
<p>链接：把类的二进制数据合并到JRE中；</p>
<p>校验：检查载入Class文件数据的正确性；</p>
<p>准备：给类的静态变量分配存储空间；</p>
<p>解析：将符号引用转成直接引用；</p>
<p>初始化：对类的静态变量，静态代码块执行初始化操作</p>
<h3 id="15-JVM字节码文件对象的结构"><a href="#15-JVM字节码文件对象的结构" class="headerlink" title="15.JVM字节码文件对象的结构"></a>15.JVM字节码文件对象的结构</h3><p>对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。</p>
<p>对象头主要包含两部分数据：MarkWord、类型指针。MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据，</p>
<p>实例数据存储代码中所定义的各种类型的字段信息。</p>
<p>对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。</p>
<h3 id="16-元空间，永久代都是方法区的实现"><a href="#16-元空间，永久代都是方法区的实现" class="headerlink" title="16.元空间，永久代都是方法区的实现"></a>16.元空间，永久代都是方法区的实现</h3><h2 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h2><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="1-TCP协议如何保证可靠传输"><a href="#1-TCP协议如何保证可靠传输" class="headerlink" title="1.TCP协议如何保证可靠传输"></a>1.TCP协议如何保证可靠传输</h4><ol>
<li>TCP给每个发送的包进行编号，接收方对数据包进行排序，把有序的数据传送给应用层。</li>
<li><strong>校验和：</strong>TCP将保持它首部和数据的校验和，如果收到的段的校验和有差错，TCP将丢弃这个报文段。</li>
<li>TCP接收端会丢弃重复的数据</li>
<li><strong>流量控制：</strong>TCP连接的每一方都有固定大小的缓冲区，TCP接收方只允许发送方发送给接收端缓冲区能接纳的数据。当接收方来不及处理发送发发送的数据，机会提示对方降低发送速率，防止丢包，利用滑动窗口实现流量控制。</li>
<li><strong>拥塞控制：</strong>当网络拥塞时，就会减少数据的发送。</li>
<li><strong>ARQ协议：</strong>基本原理就是每发完一个分组就停止发送，等待对方确认后再发送下一个分组。停止等待ARQ于连续ARQ。</li>
<li><strong>超时重传：</strong>当TCP发送了一个报文段后，会启动一个定时器，如果在规定时间内没有返回确认信号便会重新发送上次的报文段。</li>
</ol>
<h4 id="2-拥塞控制"><a href="#2-拥塞控制" class="headerlink" title="2.拥塞控制"></a>2.拥塞控制</h4><p>在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变化，这就是拥塞。</p>
<p>发送方需要维持一个拥塞窗口的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取拥塞控制窗口和接收方接收窗口中较小的一个。</p>
<p>拥塞控制的四种算法：</p>
<p><strong>慢开始：</strong>当主机开始向网络中发送数据的时候，不会一下子就把发送窗口设置很大，cwnd的初始值为一，没经过一次传播轮次，cwnd加倍。</p>
<p><strong>拥塞避免：</strong>思路是缓慢的让拥塞控制窗口缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1。</p>
<p><strong>快重传与快恢复（fast retransmit and recovery:FRR)：</strong>能够快速恢复丢失的数据包，没有FRR，TCP将会使用定时器来要求传输暂停。再暂停的这段时间内，没有新的或者复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据端，他会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认（dup-ACK)，就会假定这个数据段已经丢失了，并立即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复能够有效工作，但是有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
<h4 id="3-输入URL后的工作过程"><a href="#3-输入URL后的工作过程" class="headerlink" title="3.输入URL后的工作过程"></a>3.输入URL后的工作过程</h4><ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送http请求</li>
<li>服务器处理请求并返回http报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接</li>
</ol>
<h4 id="4-SSL-TLS协议"><a href="#4-SSL-TLS协议" class="headerlink" title="4.SSL/TLS协议"></a>4.SSL/TLS协议</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cnyygydsk/article/details/53197024">SSL协议</a></p>
<p><strong>单项认证：</strong></p>
<ol>
<li><p>   客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p>
</li>
<li><p>   服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p>
</li>
<li><pre><code>客户端使用服务端返回的信息验证服务器的合法性，包括：
</code></pre>
</li>
</ol>
<p>o 证书是否过期</p>
<p>o 发型服务器证书的CA是否可靠</p>
<p>o 返回的公钥是否能正确解开返回证书中的数字签名</p>
<p>o 服务器证书上的域名是否和服务器的实际域名相匹配</p>
<p>验证通过后，将继续进行通信，否则，终止通信</p>
<ol start="4">
<li>   客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li>
<li>   服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</li>
<li>   服务器将选择好的加密方案通过明文方式返回给客户端</li>
<li>   客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码（master_secret = PRF(pre_master_secret, “master secret”, ClientHello.random + ServerHello.random)），用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器。</li>
<li>   服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。<br>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</li>
</ol>
<p><strong>双向认证：</strong></p>
<ol>
<li><p>   客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p>
</li>
<li><p>   服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p>
</li>
<li><pre><code>客户端使用服务端返回的信息验证服务器的合法性，包括：
</code></pre>
</li>
</ol>
<p>o 证书是否过期</p>
<p>o 发型服务器证书的CA是否可靠</p>
<p>o 返回的公钥是否能正确解开返回证书中的数字签名</p>
<p>o 服务器证书上的域名是否和服务器的实际域名相匹配</p>
<p>验证通过后，将继续进行通信，否则，终止通信</p>
<ol start="4">
<li><p>   服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</p>
</li>
<li><p>   验证客户端的证书，通过验证后，会获得客户端的公钥</p>
</li>
<li><p>   客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</p>
</li>
<li><p>   服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</p>
</li>
<li><p>   将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</p>
</li>
<li><p>   客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</p>
</li>
<li><p> 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</p>
</li>
</ol>
<h4 id="5-http的报头"><a href="#5-http的报头" class="headerlink" title="5.http的报头"></a>5.http的报头</h4><p>请求报文：请求的方法，URL,协议版本</p>
<blockquote>
<p>请求的方法：get,post,delete</p>
</blockquote>
<p>回应报文：协议版本，状态码，原因短语</p>
<h4 id="6-状态码"><a href="#6-状态码" class="headerlink" title="6.状态码"></a>6.状态码</h4><p>informational:接收的请求正在处理</p>
<p>success:请求正常处理完毕</p>
<p>redirection:需要进行附加操作以完成请求</p>
<p>client error:服务端无法处理请求</p>
<p>server error:服务器处理请求出错</p>
<h4 id="7-http长连接与短连接"><a href="#7-http长连接与短连接" class="headerlink" title="7.http长连接与短连接"></a>7.http长连接与短连接</h4><p>http1.0默认短连接</p>
<p>http1.1默认长连接</p>
<h4 id="8-如何理解http协议是无状态的"><a href="#8-如何理解http协议是无状态的" class="headerlink" title="8.如何理解http协议是无状态的"></a>8.如何理解http协议是无状态的</h4><p>指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系</p>
<h4 id="9-网络404"><a href="#9-网络404" class="headerlink" title="9.网络404"></a>9.网络404</h4><p>服务器无法提供信息或服务器无法回应且不知道原因</p>
<p>导致这个错误的原因一般有三种：</p>
<ol>
<li>无法再所请求的端口上访问Web站点</li>
<li>Web服务扩展锁定策略阻止本请求</li>
<li>MIME映射策略阻止本请求</li>
</ol>
<h4 id="10-session-cookie-token"><a href="#10-session-cookie-token" class="headerlink" title="10.session,cookie,token"></a>10.session,cookie,token</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chendasheng/article/details/10705418">https://blog.csdn.net/chendasheng/article/details/10705418</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/c880420/article/details/80346127">https://blog.csdn.net/c880420/article/details/80346127</a></p>
</blockquote>
<h4 id="11-http1-0，http1-1与http2-0的主要区别是什么"><a href="#11-http1-0，http1-1与http2-0的主要区别是什么" class="headerlink" title="11.http1.0，http1.1与http2.0的主要区别是什么"></a>11.http1.0，http1.1与http2.0的主要区别是什么</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A">三者区别</a></p>
<p>http1.0:长连接，range域，缓存处理，新的错误通知如410（Gone）表示服务器上的某个资源被永久性的删除，Host头处理,增加了主机名。</p>
<p>http2.0:header压缩，多路复用降低延迟，请求优先级，服务端推送。</p>
<h4 id="12-http与https的区别"><a href="#12-http与https的区别" class="headerlink" title="12.http与https的区别"></a>12.http与https的区别</h4><ol>
<li><strong>端口：</strong>http的默认端口是80，https的默认端口是443</li>
<li><strong>安全性与资源消耗：</strong>http运行在TCP之上，，所有的传输都是明文，客户端与服务器端都无法验证对方身份。https是运行在TLS/SSL之上的协议，SSL/TLS运行在TCP之上。所有的传输内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器的证书进行了非对称加密，https的安全性更高，但是回耗费更多的服务器资源。</li>
</ol>
<p><strong>对称加密：</strong>密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的加密算法有DES,AES。</p>
<p><strong>非对称加密：</strong>密钥成对出现（公钥无法推知私钥，私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，加密算法有RSA,DSA。</p>
<h4 id="13-URI与URL的区别"><a href="#13-URI与URL的区别" class="headerlink" title="13.URI与URL的区别"></a>13.URI与URL的区别</h4><p>URI是统一资源标志符，可以唯一标识一个资源</p>
<p>URL是统一资源定位符，可以提供该资源的路径。它是一种具体的URI,可以用来标识一个资源，而且指明了如何locate这个资源</p>
<h4 id="14-HTTP请求的header头解析"><a href="#14-HTTP请求的header头解析" class="headerlink" title="14.HTTP请求的header头解析"></a>14.HTTP请求的header头解析</h4><ol>
<li>Accept:浏览器可以接受的媒体类型，服务端无法返回则返回一个406错误</li>
<li>Accept_Encoding:浏览器接受的编码方法<font color='red'>(不是指字符编码）</font>,通常指压缩方法，是否支持压缩，支持什么压缩方法（gzip,deflate)</li>
<li>Accept-Language:l浏览器申明自己接收的语言</li>
<li>Connection:如keep-alive</li>
<li>Host:指定被请求资源的internet主机和端口号，它通常是从http url中提取出来的</li>
<li>Referer:告诉服务器我是从哪个页面链接过来的,是一个url</li>
<li>User-Agent:客户端使用的操作系统和浏览器的名称和版本</li>
</ol>
<h4 id="15-http回应的header头解析"><a href="#15-http回应的header头解析" class="headerlink" title="15.http回应的header头解析"></a>15.http回应的header头解析</h4><p>Date 服务器端时间<br>Server 服务器端的服务器软件 /2.2.6++<br>Etag 文件标识符<br>Content-Encoding传送启用了GZIP压缩 gzip<br>Content-Length 内容长度<br>Content-Type 内容类型</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013252047/article/details/80116742">header</a></p>
<h4 id="14-get请求与post请求区别"><a href="#14-get请求与post请求区别" class="headerlink" title="14.get请求与post请求区别"></a>14.get请求与post请求区别</h4><p>http格式：</p>
<ol>
<li><p>请求行：请求方式，URL，协议版本</p>
</li>
<li><p>请求头：</p>
</li>
</ol>
<p>host:服务器地址，可以是ip地址或者域名</p>
<p>User-Agent:发送请求 的应用程序名称</p>
<p>Connection:krrp-alive</p>
<p>Accept-charset:服务器端可以发送的编码格式utf-8,json</p>
<p>Accept-encoding:服务器可以发送的数据压缩格式gzip</p>
<p>accept-language:服务端可以发送的语言zh-cn</p>
<ol start="3">
<li>请求正文：post请求才有</li>
</ol>
<p><strong>响应头</strong></p>
<ol>
<li>server:服务器应用程序软件名称和版本</li>
<li>content-type:响应正文的类型（是图片还是二进制字符串）</li>
<li>content-length:正文长度</li>
<li>content-charset:正文编码</li>
<li>content-encoding:数据压缩格式</li>
<li>content-language:响应正文使用的语言</li>
</ol>
<h4 id="15-转发与重定向"><a href="#15-转发与重定向" class="headerlink" title="15.转发与重定向"></a>15.转发与重定向</h4><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>1、请求次数：重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次；</p>
<p>2、地址栏不同：重定向地址栏会发生变化，转发地址栏不会发生变化；</p>
<p>3、是否共享数据：重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）；</p>
<p>4、跳转限制：重定向可以跳转到任意URL，转发只能跳转本站点资源；</p>
<p>5、发生行为不同：重定向是客户端行为，转发是服务器端行为；</p>
<h4 id="16-cp连接管理中的保活机制"><a href="#16-cp连接管理中的保活机制" class="headerlink" title="16.cp连接管理中的保活机制"></a>16.cp连接管理中的保活机制</h4><p>tcp通信中，若两端长时间没有数据往来，则这时候每隔一段时间，服务端会向客户端发送一个保活探测数据报，要求客户端进行回复。若连续多次没有收到响应，就认为连接已经断开。长时间默认为7200s，每隔一段时间默认为75s，连续多次无响应默认为9次。这些数据都可以在套接字中修改。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>为什么要用设计模式：模式是一种问题的解决思路，并且已经适用于一个实际环境，并且可以适用于其他环境。设计模式通常是对于某一类软件设计问题的可重用的解决方案，将设计模式引入软件设计和开发过程，其目的在于要重用软件开发经验。</p>
<p>作用：</p>
<ol>
<li>重用设计，比重用代码更加有意义，他会自动带来代码的重用。</li>
<li>在开发文档中使用设计模式词汇可以让其他人更容易理解你的想法和做法，编写开发文档也更方便。</li>
<li>应用设计模式可以让重构系统变得容易，可以确保开发正确的代码，并可以降低在设计和实现中出现错误的可能。</li>
<li>支持变化，可以为重写其他应用程序提供很好的系统架构。</li>
<li>正确的设计模式，可以节省大量时间。</li>
</ol>
<h4 id="1-设计模式六大原则："><a href="#1-设计模式六大原则：" class="headerlink" title="1.设计模式六大原则："></a>1.设计模式六大原则：</h4><ul>
<li>单一职责原则：一个类，方法或者接口只负责一个职责，降低代码复杂度以及变更引起的风险。</li>
<li>接口隔离原则：将不同功能定义在不同接口中实现接口隔离。</li>
<li>依赖倒转原则：针对接口编程，依赖于抽象类或接口而不是依赖于具体实现类。</li>
<li>里氏替换原则：任基类出现的地方，子类一定可以出现。</li>
<li>开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不用去修改源代码，实现一个热插拔的作用。</li>
<li>迪米特法则：每一个对于其他模块要尽可能少的了解和依赖，降低代码耦合度。</li>
<li>合成复用原则：尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</li>
</ul>
<p>其中其他原则都是为了 开放封闭原则</p>
<h4 id="2-说一下你理解的几种设计模式"><a href="#2-说一下你理解的几种设计模式" class="headerlink" title="2.说一下你理解的几种设计模式"></a>2.说一下你理解的几种设计模式</h4><p>简单工厂模式：指由一个工厂对象来创建实例,适用于工厂类负责创建对象较少的情况。例子：Spring 中的 BeanFactory 使用简单工厂模式，产生 Bean 对象。</p>
<p>代理模式为其他对象提供一种代理以控制对这个对象的访问。优点是可以增强目标对象的功能，降低代码耦合度，扩展性好。缺点是在客户端和目标对象之间增加代理对象会导致请求处理速度变慢，增加系统复杂度</p>
<h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h3 id="1-有大量请求同时发送到服务端该如何处理？"><a href="#1-有大量请求同时发送到服务端该如何处理？" class="headerlink" title="1.有大量请求同时发送到服务端该如何处理？"></a>1.有大量请求同时发送到服务端该如何处理？</h3><p>前端：秒杀按钮设计成只能安一次，避免单个用户不断点击发送很多次请求。</p>
<p>秒杀失败提示当前服务忙，等待几秒之后继续能够操作。</p>
<p>后端：</p>
<ol>
<li>静态资源与后台服务进行分离，静态资源比如图片，视频，js,css等放到静态资源服务器。</li>
<li>页面静态化，将数据渲染的动态页面编程一个html静态页面保存起来，如果以后需要再次访问该页面，则将该请求重定向到静态页面。这样就不需要再向数据库或者缓存中拿去数据然后再进行渲染页面，返回到客户端。大大的提高了响应速度，减轻了服务端的负担。nginx就自带了页面静态化的解决方案。</li>
<li>分布式和集群，</li>
<li>反向代理，可以用nginx做负载均衡，避免集群里的应用服务分配请求不均匀导致的个别应用服务器宕机问题。</li>
<li>数据库集群和拆分，一个数据库的并发数是有限的，我们需要用多个数据库来提供服务，增加并发量，这是就需要对数据库做一个集群。数据库本身也是需要进行优化的，我们需要对数据库进行垂直拆分和水平拆分。垂直拆分就是将数据表按照功能模块来进行划分，分别存储在不同的数据库服务器中。水平拆分就是对数据表进行读写分离，一个数据表或许有很多字段，但是有些字段可能在有些页面中读取较多，有些字段在其他页面写入修改较多，这时候我们就应该进行读写分离，将读较多的字段拆分为一个数据表，将写较多的字段拆分为另一个数据表。</li>
<li>使用缓存，比如redis。还可以进行数据预热，将所需要的数据线导入到缓存中去</li>
<li>消息队列流量削峰。</li>
<li>服务降级，当请求到达系统承受能力，可以对其他不核心的功能先关闭，尽可能把系统内存全部给秒杀功能，保证秒杀的正常运行。</li>
<li>服务限流，限流是接口的访问请求进行限流，也可以用rabbitmq进行限流，mq会对队列进行排队限流，一旦超过过期时间，则会丢弃，客户端快速失败进行第二轮重试。</li>
<li>拒绝请求，当服务降级和服务限流不能解决的情况下，最后就只能返回一个错误页面给用户，比如“用户请求过多”“服务繁忙，稍后再试”等，只会发生在服务器过载时候启用，只会存在短暂不可用情况，一旦正常运行的服务器负载降下来，则可以正常请求。</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-sorted-set底层数据结构"><a href="#1-sorted-set底层数据结构" class="headerlink" title="1.sorted set底层数据结构"></a>1.sorted set底层数据结构</h3><ul>
<li>有序集合保存的元素数量小于128个</li>
<li>有序集合保存的所有元素的长度小于64字节</li>
</ul>
<p>此时用的是ziplist，不满足的时候用的skiplist,插入操作的时间复杂度是O（logN)。</p>
<h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h3><ul>
<li><strong>list键</strong>：双向链表</li>
<li><strong>hash键</strong>：字典dict</li>
<li><strong>set键：</strong>intset, hashtable</li>
<li><strong>zset键</strong>：跳跃表zskiplist</li>
</ul>
<h3 id="3-redis与memcached区别"><a href="#3-redis与memcached区别" class="headerlink" title="3.redis与memcached区别"></a>3.redis与memcached区别</h3><ol>
<li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</li>
<li> Redis支持数据的备份，即master-slave模式的数据备份。</li>
<li> Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>redis 单核，mamecahce支持多核,100K 以上数据后者更快</li>
</ol>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h4 id="1-二叉树DFS"><a href="#1-二叉树DFS" class="headerlink" title="1.二叉树DFS"></a>1.二叉树DFS</h4><ol>
<li>确定返回条件（必须有，要不然会出问题，递归到最后一个结点，必须返回一个值回去，有些时候没有返回值，可能在满足遍历到最后一个结点的时候，参数列表中某些值需要改变如集合中添加元素）。</li>
<li>如果中间需要某些结点需要返回的话，写在递归代码的前面，起到剪枝的作用。</li>
<li>递归代码，可以理解成接收下一个结点的返回值，因为有递归所以不满足剪枝条件挥或者返回条件就会递归到最后一个结点。</li>
</ol>
<h4 id="2-二分法注意事项"><a href="#2-二分法注意事项" class="headerlink" title="2.二分法注意事项"></a>2.二分法注意事项</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=t;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;=left)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;<span class="comment">//这里不能写成int mid=left/2+right/2;</span></span><br><span class="line">            <span class="keyword">if</span>(mid*mid==t)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span>)mid*mid&lt;t)&#123;</span><br><span class="line">                res=mid;<span class="comment">//这里是比平方小的前一个数</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res2=mid;<span class="comment">//这里是比平方大的后一个数</span></span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="左程云算法"><a href="#左程云算法" class="headerlink" title="左程云算法"></a>左程云算法</h2><h4 id="1-数据流的中位数"><a href="#1-数据流的中位数" class="headerlink" title="1. 数据流的中位数"></a>1. 数据流的中位数</h4><p>构建一个小根堆与大根堆，第一个数先放进大根堆，其他数来的时候，如果小于等于根堆顶部的数则放入大根堆，其余放入小根堆，如果两个堆的size&gt;=2,则将多的堆的顶部的数弹出来放到另外一个根堆，这样小根堆存放最大的一半数，大根堆存放较小的一半数，各自顶端的数就是中间的数。</p>
<h4 id="2-前缀树"><a href="#2-前缀树" class="headerlink" title="2.前缀树"></a>2.前缀树</h4><p>结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pass;<span class="comment">//通过这个点的路径个数</span></span><br><span class="line">    <span class="keyword">int</span> end;<span class="comment">//以这个点为末尾的路径个数</span></span><br><span class="line">    HashMap&lt;Character,TreeNode&gt; map;<span class="comment">//路径名是character ，路径连接的下一个结点时TreeNode</span></span><br><span class="line">    List&lt;TreeNode&gt;[<span class="number">26</span>] list;<span class="comment">//如果只有字母的话</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-图的结构模板"><a href="#3-图的结构模板" class="headerlink" title="3.图的结构模板"></a>3.图的结构模板</h4><h4 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4.贪心算法"></a>4.贪心算法</h4><p>经常用到根堆！！</p>
<p>如切金条的问题就是哈夫曼树</p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>尊敬的面试官，您好。我叫陈龙，目前就读于南京大学现代工程与应用科学学院，专业是光学工程。在科研期间，接触到了软件开发相关事务，并积极参与，遇到了挑战，但也对计算机产生了浓厚兴趣，课后自学了数据结构，计算机网络，操作系统等计算机专业相关知识，为了以后从事相关行业，以java语言入门学习了相关技术栈如ssm框架，数据库,多线程，消息队列等，今天应聘的岗位是后端开发，谢谢，我的介绍完毕。</p>
<h2 id="还没解决的问题："><a href="#还没解决的问题：" class="headerlink" title="还没解决的问题："></a>还没解决的问题：</h2><p>CMS垃圾收集器与Z垃圾收集器</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/cl.github.io/2021/07/21/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/cl.github.io/2021/07/24/lalala/" rel="next" title="lalala">
      lalala <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-B%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%87%8F%E5%B0%91IO%E6%AC%A1%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">1. B树为什么可以减少IO次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-innodb%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">2. innodb四大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%EF%BC%88Insert-buffer%EF%BC%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 插入缓冲（Insert buffer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E4%BA%8C%E6%AC%A1%E5%86%99%EF%BC%88double-write"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 二次写（double write)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 自适应哈希索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E9%A2%84%E8%AF%BB"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 预读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-MyISAM%E4%B8%8EinnoDB%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">3. MyISAM与innoDB区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B4%A2%E5%BC%95"><span class="nav-number">1.4.</span> <span class="nav-text">4.索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-MyISAM"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 MyISAM</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-innoDB"><span class="nav-number">1.5.</span> <span class="nav-text">4.2 innoDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.6.</span> <span class="nav-text">4.3 事务的四大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">1.7.</span> <span class="nav-text">4.4 数据库的三大范式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.</span> <span class="nav-text">4.5 数据库并发操作带来的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.9.</span> <span class="nav-text">4.6 事务的隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E9%94%81"><span class="nav-number">1.10.</span> <span class="nav-text">4.7 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-1-%E9%97%B4%E9%9A%99%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.10.1.</span> <span class="nav-text">4.7.1 间隙锁是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-2-%E6%AD%BB%E9%94%81"><span class="nav-number">1.10.2.</span> <span class="nav-text">4.7.2 死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">1.11.</span> <span class="nav-text">4.8 分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-1-%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA"><span class="nav-number">1.11.1.</span> <span class="nav-text">4.8.1 垂直分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-2-%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA"><span class="nav-number">1.11.2.</span> <span class="nav-text">4.8.2 水平分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-3-%E5%88%86%E5%8C%BA%E5%90%8E%E4%B8%BB%E9%94%AE%E6%80%8E%E4%B9%88%E5%AE%9A"><span class="nav-number">1.11.3.</span> <span class="nav-text">4.8.3 分区后主键怎么定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">1.12.</span> <span class="nav-text">4.9 索引优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-%E7%B4%A2%E5%BC%95%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="nav-number">1.13.</span> <span class="nav-text">4.10 索引在什么情况下会失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-11-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="nav-number">1.14.</span> <span class="nav-text">4.11 什么时候需要建立索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-12-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.15.</span> <span class="nav-text">4.12 什么时候不需要创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-13-MVCC%EF%BC%88%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="nav-number">1.16.</span> <span class="nav-text">4.13 MVCC（多版本并发控制）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-14-Mysql%E7%9A%84lru%E4%BC%98%E5%8C%96"><span class="nav-number">1.17.</span> <span class="nav-text">4.14 Mysql的lru优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-15-explain%E5%AD%97%E6%AE%B5"><span class="nav-number">1.18.</span> <span class="nav-text">4.15 explain字段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">2.1.</span> <span class="nav-text">1.可重入锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-volatile"><span class="nav-number">2.2.</span> <span class="nav-text">2.volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E8%AF%BB%E5%86%99%E8%AF%AD%E4%B9%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 读写语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E8%AF%AD%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 语义实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">3.上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%AD%BB%E9%94%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.4.</span> <span class="nav-text">4.死锁条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E7%94%A8start-%E6%96%B9%E6%B3%95%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8Crun-%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8run-%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number">2.5.</span> <span class="nav-text">5.为什么要调用start()方法然后执行run()，而不是直接调用run()方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-synchronized"><span class="nav-number">2.6.</span> <span class="nav-text">6.synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81cpu%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%99%A8%EF%BC%9A"><span class="nav-number">2.7.</span> <span class="nav-text">7.为什么需要cpu高速缓冲器：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-synchronized%E4%B8%8Evolatile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.8.</span> <span class="nav-text">8.synchronized与volatile的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-ThreadLocal"><span class="nav-number">2.9.</span> <span class="nav-text">9.ThreadLocal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.10.</span> <span class="nav-text">10.线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-execute-%E6%96%B9%E6%B3%95%E4%B8%8Esubmit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.10.1.</span> <span class="nav-text">1.execute()方法与submit()方法的区别是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.10.2.</span> <span class="nav-text">2.如何创建线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">2.11.</span> <span class="nav-text">11.Atomic原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-AQS%EF%BC%88AbstractQueuedSynchronizer"><span class="nav-number">2.12.</span> <span class="nav-text">12.AQS（AbstractQueuedSynchronizer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3CAS%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98"><span class="nav-number">2.13.</span> <span class="nav-text">13.如何解决CAS中的ABA问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-String%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-number">3.1.</span> <span class="nav-text">1.1 String为什么不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">1.2 接口与抽象类有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.3.</span> <span class="nav-text">1.3 哈希碰撞是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E"><span class="nav-number">3.4.</span> <span class="nav-text">1.4 如何减少哈希碰撞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">3.5.</span> <span class="nav-text">1.5 常见的异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-final%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.6.</span> <span class="nav-text">1.6 final语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-BIO-NIO-AIO%E5%8C%BA%E5%88%AB"><span class="nav-number">3.7.</span> <span class="nav-text">1.7 BIO,NIO,AIO区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-CopyOnWriteArraylist"><span class="nav-number">3.8.</span> <span class="nav-text">1.8 CopyOnWriteArraylist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.9.</span> <span class="nav-text">1.9 实例化对象的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-JDK8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">3.10.</span> <span class="nav-text">1.10 JDK8新特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E9%9B%86%E5%90%88"><span class="nav-number">4.</span> <span class="nav-text">java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ArrayList%E4%B8%8ELinkedListb%E6%AF%94%E8%BE%83"><span class="nav-number">4.1.</span> <span class="nav-text">1.ArrayList与LinkedListb比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ArrayList"><span class="nav-number">4.2.</span> <span class="nav-text">2.ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-HashMap%E4%B8%8EHashtable"><span class="nav-number">4.3.</span> <span class="nav-text">3.HashMap与Hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.4.</span> <span class="nav-text">4.HashMap底层实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-jdk8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">4.5.</span> <span class="nav-text">5.jdk8的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%82%E7%94%A8avl%E6%A0%91%E8%80%8C%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">4.5.1.</span> <span class="nav-text">6.HashMap为什么不适用avl树而使用红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84"><span class="nav-number">4.5.2.</span> <span class="nav-text">7.红黑树结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.1.</span> <span class="nav-text">1.1 什么是操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">1.2 系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">1.3 进程与线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">1.4 进程间的通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">5.5.</span> <span class="nav-text">1.5 线程之间同步方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">5.6.</span> <span class="nav-text">1.6 进程的调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">5.7.</span> <span class="nav-text">1.7 内存管理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.8.</span> <span class="nav-text">1.8 分页机制与分段机制的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-%E9%A1%B5%E8%A1%A8"><span class="nav-number">5.9.</span> <span class="nav-text">1.9 页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-%E5%BF%AB%E8%A1%A8"><span class="nav-number">5.10.</span> <span class="nav-text">1.10 快表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-CPU%E5%AF%BB%E5%9D%80"><span class="nav-number">5.11.</span> <span class="nav-text">1.11 CPU寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="nav-number">5.12.</span> <span class="nav-text">1.12 为什么需要虚拟地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">5.13.</span> <span class="nav-text">1.13 什么是虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">5.14.</span> <span class="nav-text">1.14 局部性原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.15.</span> <span class="nav-text">1.15 虚拟内存的技术实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-%E8%BF%99%E4%BA%9B%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%BC%9A%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">5.16.</span> <span class="nav-text">1.16 这些管理方式会遇到什么问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-17%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">5.17.</span> <span class="nav-text">1.17页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-18-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.18.</span> <span class="nav-text">1.18 上下文是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-19-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%8A%B6%E6%80%81"><span class="nav-number">5.19.</span> <span class="nav-text">1.19 进程的三大状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-20-select-poll-epoll%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.20.</span> <span class="nav-text">1.20 select,poll epoll模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-21-IO%E6%A8%A1%E5%9E%8B-%E9%93%BE%E6%8E%A5"><span class="nav-number">5.21.</span> <span class="nav-text">1.21 IO模型 链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-22-%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="nav-number">5.22.</span> <span class="nav-text">1.22 非阻塞与异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-23-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.23.</span> <span class="nav-text">1.23 僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-25-kill"><span class="nav-number">5.24.</span> <span class="nav-text">1.25 kill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-24-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.25.</span> <span class="nav-text">1.24 孤儿进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">6.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">6.1.</span> <span class="nav-text">1.程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">6.2.</span> <span class="nav-text">2.虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">6.3.</span> <span class="nav-text">3.方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">6.4.</span> <span class="nav-text">4.运行时常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">6.5.</span> <span class="nav-text">5.java对象创建的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%9C%89%E5%93%AA%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">6.6.</span> <span class="nav-text">6.对象访问有哪两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-number">6.7.</span> <span class="nav-text">7.JVM内存分配与回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%B7%B2%E7%BB%8F%E6%AD%BB%E4%BA%A1"><span class="nav-number">6.8.</span> <span class="nav-text">8.如何判断对象已经死亡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E4%BB%80%E4%B9%88%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Roots"><span class="nav-number">6.9.</span> <span class="nav-text">9.什么对象可以作为GC Roots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%BC%BA%EF%BC%8C%E8%BD%AF%EF%BC%8C%E5%BC%B1%EF%BC%8C%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-number">6.10.</span> <span class="nav-text">10.强，软，弱，虚引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84"><span class="nav-number">6.11.</span> <span class="nav-text">11.如何判断一个类是无用的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.12.</span> <span class="nav-text">12.垃圾收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">6.13.</span> <span class="nav-text">13.垃圾收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">6.14.</span> <span class="nav-text">14.类加载过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">6.15.</span> <span class="nav-text">15.JVM字节码文件对象的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E9%83%BD%E6%98%AF%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.16.</span> <span class="nav-text">16.元空间，永久代都是方法区的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E6%8C%87%E4%BB%A4"><span class="nav-number">7.</span> <span class="nav-text">Linux指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">8.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">8.0.1.</span> <span class="nav-text">1.TCP协议如何保证可靠传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">8.0.2.</span> <span class="nav-text">2.拥塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%BE%93%E5%85%A5URL%E5%90%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">8.0.3.</span> <span class="nav-text">3.输入URL后的工作过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-SSL-TLS%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.0.4.</span> <span class="nav-text">4.SSL&#x2F;TLS协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-http%E7%9A%84%E6%8A%A5%E5%A4%B4"><span class="nav-number">8.0.5.</span> <span class="nav-text">5.http的报头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">8.0.6.</span> <span class="nav-text">6.状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-http%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">8.0.7.</span> <span class="nav-text">7.http长连接与短连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84"><span class="nav-number">8.0.8.</span> <span class="nav-text">8.如何理解http协议是无状态的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E7%BD%91%E7%BB%9C404"><span class="nav-number">8.0.9.</span> <span class="nav-text">9.网络404</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-session-cookie-token"><span class="nav-number">8.0.10.</span> <span class="nav-text">10.session,cookie,token</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-http1-0%EF%BC%8Chttp1-1%E4%B8%8Ehttp2-0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">8.0.11.</span> <span class="nav-text">11.http1.0，http1.1与http2.0的主要区别是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.0.12.</span> <span class="nav-text">12.http与https的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-URI%E4%B8%8EURL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.0.13.</span> <span class="nav-text">13.URI与URL的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-HTTP%E8%AF%B7%E6%B1%82%E7%9A%84header%E5%A4%B4%E8%A7%A3%E6%9E%90"><span class="nav-number">8.0.14.</span> <span class="nav-text">14.HTTP请求的header头解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-http%E5%9B%9E%E5%BA%94%E7%9A%84header%E5%A4%B4%E8%A7%A3%E6%9E%90"><span class="nav-number">8.0.15.</span> <span class="nav-text">15.http回应的header头解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-get%E8%AF%B7%E6%B1%82%E4%B8%8Epost%E8%AF%B7%E6%B1%82%E5%8C%BA%E5%88%AB"><span class="nav-number">8.0.16.</span> <span class="nav-text">14.get请求与post请求区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">8.0.17.</span> <span class="nav-text">15.转发与重定向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">8.1.</span> <span class="nav-text">区别：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#16-cp%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6"><span class="nav-number">8.1.1.</span> <span class="nav-text">16.cp连接管理中的保活机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="nav-number">9.0.1.</span> <span class="nav-text">1.设计模式六大原则：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.0.2.</span> <span class="nav-text">2.说一下你理解的几种设计模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaWeb"><span class="nav-number">10.</span> <span class="nav-text">JavaWeb</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9C%89%E5%A4%A7%E9%87%8F%E8%AF%B7%E6%B1%82%E5%90%8C%E6%97%B6%E5%8F%91%E9%80%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">10.1.</span> <span class="nav-text">1.有大量请求同时发送到服务端该如何处理？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">11.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-sorted-set%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">11.1.</span> <span class="nav-text">1.sorted set底层数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">11.2.</span> <span class="nav-text">2.数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-redis%E4%B8%8Ememcached%E5%8C%BA%E5%88%AB"><span class="nav-number">11.3.</span> <span class="nav-text">3.redis与memcached区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91DFS"><span class="nav-number">12.0.1.</span> <span class="nav-text">1.二叉树DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BA%8C%E5%88%86%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">12.0.2.</span> <span class="nav-text">2.二分法注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95"><span class="nav-number">13.</span> <span class="nav-text">左程云算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">13.0.1.</span> <span class="nav-text">1. 数据流的中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">13.0.2.</span> <span class="nav-text">2.前缀树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%9B%BE%E7%9A%84%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">13.0.3.</span> <span class="nav-text">3.图的结构模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">13.0.4.</span> <span class="nav-text">4.贪心算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="nav-number">14.</span> <span class="nav-text">自我介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%98%E6%B2%A1%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">15.</span> <span class="nav-text">还没解决的问题：</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CL</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/cl.github.io/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CL</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/cl.github.io/lib/anime.min.js"></script>
  <script src="/cl.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/cl.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/cl.github.io/js/utils.js"></script>

<script src="/cl.github.io/js/motion.js"></script>


<script src="/cl.github.io/js/schemes/pisces.js"></script>


<script src="/cl.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>

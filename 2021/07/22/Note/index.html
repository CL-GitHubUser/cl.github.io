<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="数据库1. B树为什么可以减少IO次数磁盘IO：寻道时间，旋转延迟，传输时间；每次读取加载需要地址的数据到内存，而且相邻地址的数据也加载到内存缓冲区，相当于一页，一页树相当于一次IO。数据库索引存在磁盘上，利用索引查询时，只能逐页加载每个磁盘页，这个磁盘页对应索引树的节点。 B+树非叶子结点保存的是叶子结点数据的指针，不是真实的数据，所以中间结点的存储占用的空间较少，能存更多的数据，更加矮胖，效率">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/07/22/Note/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据库1. B树为什么可以减少IO次数磁盘IO：寻道时间，旋转延迟，传输时间；每次读取加载需要地址的数据到内存，而且相邻地址的数据也加载到内存缓冲区，相当于一页，一页树相当于一次IO。数据库索引存在磁盘上，利用索引查询时，只能逐页加载每个磁盘页，这个磁盘页对应索引树的节点。 B+树非叶子结点保存的是叶子结点数据的指针，不是真实的数据，所以中间结点的存储占用的空间较少，能存更多的数据，更加矮胖，效率">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/80466/Desktop/Note/数据库死锁.png">
<meta property="article:published_time" content="2021-07-22T02:14:16.451Z">
<meta property="article:modified_time" content="2021-07-21T17:10:14.153Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/80466/Desktop/Note/数据库死锁.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Note" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/22/Note/" class="article-date">
  <time class="dt-published" datetime="2021-07-22T02:14:16.451Z" itemprop="datePublished">2021-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1-B树为什么可以减少IO次数"><a href="#1-B树为什么可以减少IO次数" class="headerlink" title="1. B树为什么可以减少IO次数"></a>1. B树为什么可以减少IO次数</h3><p>磁盘IO：寻道时间，旋转延迟，传输时间；每次读取加载需要地址的数据到内存，而且相邻地址的数据也加载到内存缓冲区，相当于一页，一页树相当于一次IO。数据库索引存在磁盘上，利用索引查询时，只能逐页加载每个磁盘页，这个磁盘页对应索引树的节点。</p>
<p>B+树非叶子结点保存的是叶子结点数据的指针，不是真实的数据，所以中间结点的存储占用的空间较少，能存更多的数据，更加矮胖，效率更高。</p>
<h3 id="2-innodb四大特性"><a href="#2-innodb四大特性" class="headerlink" title="2. innodb四大特性"></a>2. innodb四大特性</h3><h4 id="2-1-插入缓冲（Insert-buffer）"><a href="#2-1-插入缓冲（Insert-buffer）" class="headerlink" title="2.1 插入缓冲（Insert buffer）"></a>2.1 插入缓冲（Insert buffer）</h4><p>对于非聚集索引和非唯一索引有效，插入数据时下判断插入的非聚集索引页是否在缓存池中，如果在就直接插入；如果不在，先放入insert buffer ，按照一定频率进行合并操作，这样就可以将多个插入合并到一个操作，减少随机IO带来的性能损耗。</p>
<h4 id="2-2-二次写（double-write"><a href="#2-2-二次写（double-write" class="headerlink" title="2.2 二次写（double write)"></a>2.2 二次写（double write)</h4><p>flush操作：将内存中的 数据更新到磁盘中并将redo log的checkpoint前推，保持磁盘和内存的数据一致性。</p>
<p>double write缓存时位于系统表空间的存储区域，用来缓存innodb的数据页从缓存池中flush之后与写入数据文件之前，当操作系统或者书库在写磁盘的过程中崩溃就可以用double write缓存池中的树页备份进行crash恢复。</p>
<h4 id="2-3-自适应哈希索引"><a href="#2-3-自适应哈希索引" class="headerlink" title="2.3 自适应哈希索引"></a>2.3 自适应哈希索引</h4><p>innodb存储引擎会监控对表上二级索引的找查找，如果发现某二级索引被频繁访问，就会建立哈希索引来提升索引速度。但是会占用innodb buffer pool。</p>
<h4 id="2-4-预读"><a href="#2-4-预读" class="headerlink" title="2.4 预读"></a>2.4 预读</h4><p><a target="_blank" rel="noopener" href="http://www.mybatis.cn/archives/941.html">一级索引与二级索引</a></p>
<p>innodb的逻辑存储结构：表空间-&gt; 段（segment）-&gt;区（extent)-&gt;页（page)-&gt;行（row)</p>
<p>线性预读：是否将写一个extent预读到buffer pool中。</p>
<p>随机预读：如果一个extent的 一些page被发现在buffer poll中，就将该extent剩余的page加载到buffer pool中。</p>
<h3 id="3-MyISAM与innoDB区别"><a href="#3-MyISAM与innoDB区别" class="headerlink" title="3. MyISAM与innoDB区别"></a>3. MyISAM与innoDB区别</h3><p>1.后者支持事务</p>
<p>2.后者有行锁</p>
<p>3.前者强调性能，每次查询具有原子性，执行速度比innodb快，但是不支持事务。后者支持事务，外键等功能，具有事务，回滚，崩溃修复能力的事务安全型表。</p>
<p>4.后者支持外键</p>
<p>5.后者支持mvcc。</p>
<h3 id="4-索引"><a href="#4-索引" class="headerlink" title="4.索引"></a>4.索引</h3><h4 id="4-1-MyISAM"><a href="#4-1-MyISAM" class="headerlink" title="4.1 MyISAM"></a>4.1 MyISAM</h4><p>B+树叶结点存放data域是数据记录的地址。在索引检索的时候，先按照B+树的索引算法找指定的key,如果存在则取出其data域的值，然后以data域的值为内存地址取出相应的数据记录。（非聚集索引）</p>
<h3 id="4-2-innoDB"><a href="#4-2-innoDB" class="headerlink" title="4.2 innoDB"></a>4.2 innoDB</h3><p>其数据文件本身就是索引文件。相比前者，索引文件和数据文件是分离的，其表文件就是一个B+树的索引结构，树的叶子节点的data域保存了完整的数据，这个索引的key是数据表主键，数据表本身就是主索引（聚集索引）。其余的索引都是辅助索引，辅助索引data域的数据是主键值而不是地址。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuyafeng/p/11350873.html">两者索引</a></p>
<h3 id="4-3-事务的四大特性"><a href="#4-3-事务的四大特性" class="headerlink" title="4.3 事务的四大特性"></a>4.3 事务的四大特性</h3><p>原子性（Atomictity）:事务是最小的执行单元，不允许分割。事务的动作要么全部完成，要么完全不起作用。</p>
<p>一致性（Consistency）：执行事务前后，是从一个一致性状态转移到下一个一致性状态，举一个给钱的例子。</p>
<p>隔离性（Isolation）:并发访问数据库的时候，各个事务直接不能相互干扰。</p>
<p>持久性（Durability)：一个事务被提交之后，对数据库所造成的影响是持久性的，即使数据库发生故障也不应该有任何影响。</p>
<h3 id="4-4-数据库的三大范式"><a href="#4-4-数据库的三大范式" class="headerlink" title="4.4 数据库的三大范式"></a>4.4 数据库的三大范式</h3><p>范式一：列是最小信息单元，无法再次被分割</p>
<p>范式二：在满足一的基础上，非主键列不能对主键列形成部份依赖</p>
<p>范式三：在满足一二，的基础上，非主键列之间不能被形成传递依赖</p>
<h3 id="4-5-数据库并发操作带来的问题"><a href="#4-5-数据库并发操作带来的问题" class="headerlink" title="4.5 数据库并发操作带来的问题"></a>4.5 数据库并发操作带来的问题</h3><ul>
<li><p>脏读：当事务A访问数据并进行了修改，还未提交，此时，事务B也对该数据进行了访问，读取了数据，但同时事务A进行了回滚，事务B读取的数据便是“脏数据，这便是脏读。</p>
</li>
<li><p>不可重复读：指事务A在访问数据后，事务B之后对该数据进行了修改，事务A再次读取的时候域上次读取的数据不相同。</p>
</li>
<li><p>幻读：与不可重复读类似，当事务A读取一次数据后，事务B又增加了几条数据到该表中，事务A读取的时候发现多了一些数据。</p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
</li>
</ul>
<h3 id="4-6-事务的隔离级别"><a href="#4-6-事务的隔离级别" class="headerlink" title="4.6 事务的隔离级别"></a>4.6 事务的隔离级别</h3><ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。(innodb默认级别)</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<h3 id="4-7-锁"><a href="#4-7-锁" class="headerlink" title="4.7 锁"></a>4.7 锁</h3><h4 id="4-7-1-间隙锁是什么"><a href="#4-7-1-间隙锁是什么" class="headerlink" title="4.7.1 间隙锁是什么"></a>4.7.1 间隙锁是什么</h4><p>rr隔离级别下才会有间隙锁，</p>
<p>select …for update会添加行级锁，没有索引的话会将排查的行全部加锁</p>
<h4 id="4-7-2-死锁"><a href="#4-7-2-死锁" class="headerlink" title="4.7.2 死锁"></a>4.7.2 死锁</h4><p><strong>情况一：</strong>线程A访问表１并加独占锁，线程B访问表２也加了独占锁，此时线程一需要访问表２，线程二也要访问表１，双方给都不释放锁，就形成了死锁。</p>
<p><strong>情况二：</strong><img src="C:\Users\80466\Desktop\Note\数据库死锁.png" alt="死锁"></p>
<h3 id="4-8-分库分表"><a href="#4-8-分库分表" class="headerlink" title="4.8 分库分表"></a>4.8 分库分表</h3><p>实现读写分离,增加并发性</p>
<h4 id="4-8-1-垂直分区"><a href="#4-8-1-垂直分区" class="headerlink" title="4.8.1 垂直分区"></a>4.8.1 垂直分区</h4><p>根据数据库里面的数据表的相关性进行拆分,就是将一张表的列给拆分成不同的表</p>
<p>缺点:主键出现冗余,需要join操作,还会让事务变得复杂</p>
<p>优点:列数据变少,查询的时候减少block数,减少io次数,简化表的结构,易于维护</p>
<h4 id="4-8-2-水平分区"><a href="#4-8-2-水平分区" class="headerlink" title="4.8.2 水平分区"></a>4.8.2 水平分区</h4><h4 id="4-8-3-分区后主键怎么定"><a href="#4-8-3-分区后主键怎么定" class="headerlink" title="4.8.3 分区后主键怎么定"></a>4.8.3 分区后主键怎么定</h4><ul>
<li><p>UUID:32位16进制数字,连字号分为五段,形式为8-4-4-4-12的36个字符.</p>
<p>优点:性能非常高,本地生成,没有网络消耗。</p>
<p>缺点:不能作为主键,太长了;不容易储存;信息不安全如基于MAC地址生成算法;无序性导致数据位置频繁变动,严重影响性能。</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">美团leaf</a></p>
</li>
</ul>
<h3 id="4-9-索引优化"><a href="#4-9-索引优化" class="headerlink" title="4.9 索引优化"></a>4.9 索引优化</h3><p>不要盲目的创建索引，索引利于查询，插入数据，删除的效率也会降低。</p>
<ol>
<li>利用联合索引</li>
<li>利用覆盖索引</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ljl150/p/12934071.html">最佳左前缀原则</a></li>
<li>建立联合查询的时候，区分度最高的字段放在最左边</li>
<li>建立索引的列不能为null,使用not null约束及默认值。</li>
</ol>
<h3 id="4-10-索引在什么情况下会失效"><a href="#4-10-索引在什么情况下会失效" class="headerlink" title="4.10 索引在什么情况下会失效"></a>4.10 索引在什么情况下会失效</h3><ol>
<li>当索引列的值了函数运算</li>
<li>强制类型转会导致全表扫描，如当varchar属性的列查询时没有加引号</li>
<li>前导模糊查询不能使用索引，“%a”这种形式</li>
<li>负条件不能使用索引，可以优化为in查询，负条件有!=,&lt;&gt;,not in,not exists等</li>
</ol>
<h3 id="4-11-什么时候需要建立索引"><a href="#4-11-什么时候需要建立索引" class="headerlink" title="4.11 什么时候需要建立索引"></a>4.11 什么时候需要建立索引</h3><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中排序的字段创建索引将大大提高排序的速度</li>
<li>查询中统计或者分组的字段</li>
</ol>
<h3 id="4-12-什么时候不需要创建索引"><a href="#4-12-什么时候不需要创建索引" class="headerlink" title="4.12 什么时候不需要创建索引"></a>4.12 什么时候不需要创建索引</h3><ol>
<li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件。</li>
<li>where条件利用不到的字段，不创建索引</li>
<li>表记录太少，不需要创建索引</li>
<li>经常增删改的表</li>
<li>数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。</li>
</ol>
<h3 id="4-13-MVCC（多版本并发控制）"><a href="#4-13-MVCC（多版本并发控制）" class="headerlink" title="4.13 MVCC（多版本并发控制）"></a>4.13 MVCC（多版本并发控制）</h3><p>优势：读不加锁，读写不冲突</p>
<p>MVCC下rr隔离级别下，innodb的select操作回按照下面两个条件检查每行记录：</p>
<ol>
<li>InnoDB只查找创建当前版本号早于会等于当前系统版本号的数据行，这样可以确保事务读取的行，要么是在事务之前已经存在的，要么是自身插入或者修改过的。</li>
<li>行的删除版本号要么未定义，要么大于当前系统版本号（当前事务开始之后删除的）。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ol>
<p><strong>实现原理：</strong>每一行有三个隐藏键</p>
<p>**DATA_TRX_ID:**记录最近更新这行记录的事务ID</p>
<p>**DATA_ROLL_PTR:**表示指向改行回滚段的指针，innodb便是通过这个指针找到之前版本的数据。改行记录上所有的旧版本，在undo中都通过链表的形式组织。</p>
<p>**DB_ROW_ID:**行标识（隐藏单调自增ID)，如果没有主键，innodb会自动生成一个隐藏主键，即此列。</p>
<p>**redo log:**将事务最新的数据存储起来</p>
<p>**undo log:**事务未提交之前，undo log保存未提交数据之前的数据版本，当读取某一行被其他事务操作时，可以从undo log中分析出该行之前记录的数据。实现事务的原子性，mvcc也是undo log实现的。</p>
<h3 id="4-14-Mysql的lru优化"><a href="#4-14-Mysql的lru优化" class="headerlink" title="4.14 Mysql的lru优化"></a>4.14 Mysql的lru优化</h3><p>mysql在读取数据的时候会将磁盘中的数据按照页的方式加载到bufferpool的缓冲区中,还维护了一个lru链表，链表的结点指向缓冲区的数据。当缓冲区存满的时候就需要替换掉不常用的数据，就用到了lru机制。但是由于不当在操作，可能会发生全表扫描。以及innodb存在预读的操作，即会将临近的页的数据提前加载到bufferpool中，这样可能会导致缓冲区存入一些不常用的数据，导致mysql性能下降。</p>
<p><strong>优化：</strong>bufferpool对数据进行了冷热分离，，将 LRU 链表分成两部分，一部分用来存放冷数据，也就是刚从磁盘读进来的数据，另一部分用来存放热点数据，也就是经常被访问到数据。冷区大小默认是37%。</p>
<p><strong>极致优化：</strong>当一个缓存页处于热数据区域的时候，我们去访问这个缓存页，这个时候我们真的有必要把它移动到热点数据区域的头部吗？</p>
<p>从代码的角度来看，将链表中的数据移动到头部，实际上就是修改元素的指针指向，这个操作是非常快的。但是为了安全起见，在修改链表的时候，我们需要对链表加上锁，否则容易出现并发问题。</p>
<p>当并发量大的时候，因为要加锁，会存在锁竞争，每次移动显然效率就会下降。因此 MySQL 针对这一点又做了优化，如果一个缓存页处于热数据区域，且在热数据区域的前 1/4 区域（注意是热数据区域的 1/4，不是整个链表的 1/4），那么当访问这个缓存页的时候，就不用把它移动到热数据区域的头部；如果缓存页处于热数据的后 3/4 区域，那么当访问这个缓存页的时候，会把它移动到热数据区域的头部</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-可重入锁"><a href="#1-可重入锁" class="headerlink" title="1.可重入锁"></a>1.可重入锁</h3><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。ReentrantLock和synchronized都是可重入锁。当从磁盘读取数据页后，会先将数据页存放到 LRU 链表冷数据区的头部，如果这些缓存页在 1 秒之后被访问，那么就将缓存页移动到热数据区的头部；如果是 1 秒之内被访问，则不会移动，缓存页仍然处于冷数据区中。1 秒这个数值，是由参数 innodb_old_blocks_time 控制。</p>
<h3 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2.volatile"></a>2.volatile</h3><p>1.可见性</p>
<p>2.无法保证原子性，但是对于单个volatile变量的读写操作都是具有原子性的</p>
<p>3.禁止指令重排</p>
<h4 id="2-1-读写语义"><a href="#2-1-读写语义" class="headerlink" title="2.1 读写语义"></a>2.1 读写语义</h4><p>读语义：当读线程读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存读取共享变量。</p>
<p>写语义：当写线程写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>
<h4 id="2-2-语义实现原理"><a href="#2-2-语义实现原理" class="headerlink" title="2.2 语义实现原理"></a>2.2 语义实现原理</h4><ul>
<li>内存屏障：一组处理器指令，用于实现对内存操作的顺序限制</li>
<li>缓存行：CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。</li>
</ul>
<p>如何实现可见性：借助了CPU的lock指令，通过在写volatile的机械指令前加上lock前缀，使写volatile具有以下两个原则：1.写volatile时处理器会将缓存写回到主内存。2.一个处理器的缓存写回到内存会导致其他处理器的缓存失效。</p>
<p>如何实现禁止指令重排：加内存屏障</p>
<p>在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。<br>在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。<br>在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。<br>在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。</p>
<h3 id="3-上下文切换"><a href="#3-上下文切换" class="headerlink" title="3.上下文切换"></a>3.上下文切换</h3><p>多线程编程中，线程的个数大于cpu核心数，而cpu核心一次只能被一个线程使用，为了让这些线程都能够得到有效执行，cpu采用的适合为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这过程就是一次上下文切换。</p>
<h3 id="4-死锁条件"><a href="#4-死锁条件" class="headerlink" title="4.死锁条件"></a>4.死锁条件</h3><ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="5-为什么要调用start-方法然后执行run-，而不是直接调用run-方法。"><a href="#5-为什么要调用start-方法然后执行run-，而不是直接调用run-方法。" class="headerlink" title="5.为什么要调用start()方法然后执行run()，而不是直接调用run()方法。"></a>5.为什么要调用start()方法然后执行run()，而不是直接调用run()方法。</h3><p>new一个Thread,线程进入了新建状态。调用start()方法，会启动一个线程并使线程进入就绪状态，当分配到时间片之后就可以开始运行了。start()会执行线程相应的准备工作，然后自动执行run()方法的内容，这是真的正的多线程工作。但是如果直接调用run方法，把run()方法看成main()线程下的普通方法去执行，并不会再某个线程中执行它，这并不是多线程工作。</p>
<h3 id="6-synchronized"><a href="#6-synchronized" class="headerlink" title="6.synchronized"></a>6.synchronized</h3><p>构造方法不能使用synchronized修饰</p>
<p>修饰静态方法的时候，锁的是这个类，如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</p>
<p><strong>底层原理：</strong></p>
<p><strong>1.修饰代码块：</strong>synchronized同步语句块使用的是monitorenter和monitorexit指令，前者指向同步代码块开始的位置，后者表明同步代码块结束的位置。当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><strong>2.修饰方法：</strong>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</p>
<blockquote>
<p>两者本质都是对对象监视器monitor的获取。</p>
</blockquote>
<h3 id="7-为什么需要cpu高速缓冲器："><a href="#7-为什么需要cpu高速缓冲器：" class="headerlink" title="7.为什么需要cpu高速缓冲器："></a>7.为什么需要cpu高速缓冲器：</h3><p>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</p>
<p>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</p>
<h3 id="8-synchronized与volatile的区别"><a href="#8-synchronized与volatile的区别" class="headerlink" title="8.synchronized与volatile的区别"></a>8.synchronized与volatile的区别</h3><p>两者是互补的存在</p>
<p>volatile 关键字是线程同步的轻量级实现，所以<strong>volatile性能肯定比synchronized关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块</strong>。</p>
<p>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</p>
<p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</p>
<h3 id="9-ThreadLocal"><a href="#9-ThreadLocal" class="headerlink" title="9.ThreadLocal"></a>9.ThreadLocal</h3><h3 id="10-线程池"><a href="#10-线程池" class="headerlink" title="10.线程池"></a>10.线程池</h3><p><strong>优点：</strong></p>
<ol>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建以及销毁造成的消耗。</li>
<li>提高相应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h4 id="1-execute-方法与submit-方法的区别是什么"><a href="#1-execute-方法与submit-方法的区别是什么" class="headerlink" title="1.execute()方法与submit()方法的区别是什么"></a>1.execute()方法与submit()方法的区别是什么</h4><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</p>
<p>submit()方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过这个对象可以判断任务是否执行成功。并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h4 id="2-如何创建线程池"><a href="#2-如何创建线程池" class="headerlink" title="2.如何创建线程池"></a>2.如何创建线程池</h4><p>七大参数：</p>
<p>核心线程数</p>
<p>最大线程数</p>
<p>存活时间</p>
<p>时间单位</p>
<p>阻塞队列</p>
<p>线程工厂</p>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<p>拒绝策略：AbortPolicy:抛出RejectedExecutionException来拒绝新任务的处理；把任务抛出给运行自己的线程，会影响新任务的提交速度，影响程序的整体性能，还喜欢增加队列容量；直接丢弃新任务；丢弃最早的未处理的任务。</p>
<h3 id="11-Atomic原子类"><a href="#11-Atomic原子类" class="headerlink" title="11.Atomic原子类"></a>11.Atomic原子类</h3><p>基本数据类型</p>
<p>数组类型</p>
<p>引用类型</p>
<p>对象的属性修改类型</p>
<h3 id="12-AQS（AbstractQueuedSynchronizer"><a href="#12-AQS（AbstractQueuedSynchronizer" class="headerlink" title="12.AQS（AbstractQueuedSynchronizer)"></a>12.AQS（AbstractQueuedSynchronizer)</h3><p>在java.util.concurrent.locks包下,AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1-1-String为什么不可变"><a href="#1-1-String为什么不可变" class="headerlink" title="1.1 String为什么不可变"></a>1.1 String为什么不可变</h3><p>被final修饰了，是个字符数组</p>
<h3 id="1-2-接口与抽象类有什么区别"><a href="#1-2-接口与抽象类有什么区别" class="headerlink" title="1.2 接口与抽象类有什么区别"></a>1.2 接口与抽象类有什么区别</h3><p>1.接口的默认public ，抽象类内部可以有非抽象方法</p>
<p>2.接口中只能有static,final变量，而抽象类则不一定</p>
<p>3.一个类可以实现多个接口，但只能实现一个抽象类。接口本身可以多继承接口。</p>
<p>接口的方法默认修饰符是public,抽象方法可以是public,protected和default</p>
<p>4.从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口时对行为的抽象，是一种行为的规范</p>
<blockquote>
<p>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。<br>jdk 8 的时候接口可以有默认方法和静态方法功能。<br>Jdk 9 在接口中引入了私有方法和私有静态方法。</p>
</blockquote>
<h3 id="1-3-哈希碰撞是什么"><a href="#1-3-哈希碰撞是什么" class="headerlink" title="1.3 哈希碰撞是什么"></a>1.3 哈希碰撞是什么</h3><h3 id="1-4-如何减少哈希碰撞"><a href="#1-4-如何减少哈希碰撞" class="headerlink" title="1.4 如何减少哈希碰撞"></a>1.4 如何减少哈希碰撞</h3><p><strong>1.开放地址法：</strong>根据一个公式再散列。</p>
<p><strong>2.再哈哈希法：</strong>比如按照首字符哈希发生了冲入，可以按照首字母第二位进行哈希，再冲突，按照第三位进行哈希。</p>
<p><strong>3.链地址法：</strong>比如如java中的Hashmap.</p>
<p><strong>4.建立一个公共溢出区：</strong>用以存储发生冲突的记录</p>
<p>拉链法优点：</p>
<p>1.处理冲突简单，且无堆积现象。</p>
<p>2.拉链法中各链表上的结点空间是动态申请的，故他更适合于造表前无法确定表的长度的情况。</p>
<p>3.开放地址法为减少冲突，要求加载因子较小，当结点规模较大的时候会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间。</p>
<p>4.在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</p>
<h3 id="1-5-常见的异常"><a href="#1-5-常见的异常" class="headerlink" title="1.5 常见的异常"></a>1.5 常见的异常</h3><p>受检异常:IOException,ClassNotFoundException</p>
<p>不受检异常：NullPointerException,NumberFormatException,ArrayIndexOutofBoundsException,</p>
<p>ClassCastException,ArithmeticException，ConcurrentModificationException.</p>
<h3 id="1-6-final语句"><a href="#1-6-final语句" class="headerlink" title="1.6 final语句"></a>1.6 final语句</h3><p>如果try与finally中都有return,final的返回值会覆盖try中的返回值</p>
<p>finally为什么一定会执行？</p>
<p>编译器在编译Java代码的时候，会把finally代码块里的内容，复制一份，分别放在try块和catch块里所有正常执行路径以及异常执行路径的出口中</p>
<h3 id="1-7-BIO-NIO-AIO区别"><a href="#1-7-BIO-NIO-AIO区别" class="headerlink" title="1.7 BIO,NIO,AIO区别"></a>1.7 BIO,NIO,AIO区别</h3><p>**BIO:**同步阻塞I/O模式，数据的读取和写入必须阻塞在一个线程内等待其完成，简单，但是无法适应高并发。</p>
<p>**NIO:**同步非阻塞的I/O模型，java1.4引入了NIO框架，提供了Channel,Selector,Buffer等抽象。</p>
<p><strong>AIO：</strong>异步非阻塞的I/O模型。</p>
<p><em>进程中的IO调用步骤大致可以分为以下四步：</em></p>
<p><em>进程向操作系统请求数据 ;</em></p>
<p><em>操作系统把外部数据加载到内核的缓冲区中;</em></p>
<p><em>操作系统把内核的缓冲区拷贝到进程的缓冲区 ;</em></p>
<p><em>进程获得数据完成自己的功能 ;</em></p>
<p><em>当操作系统在把外部数据放到进程缓冲区的这段时间（即上述的第二，三步），如果应用进程是挂起等待的，那么就是同步IO，反之，就是异步IO，也就是AIO 。</em></p>
<p><strong>为什么epoll比poll与select效率高：</strong></p>
<p>1.减少了用户态和内核态之间的文件描述符拷贝 </p>
<p>2.减少了对就绪文件描述符的遍历</p>
<h3 id="1-8-CopyOnWriteArraylist"><a href="#1-8-CopyOnWriteArraylist" class="headerlink" title="1.8 CopyOnWriteArraylist"></a>1.8 CopyOnWriteArraylist</h3><p>写时加锁并copy数组并且大小加一</p>
<h3 id="1-9-实例化对象的方法"><a href="#1-9-实例化对象的方法" class="headerlink" title="1.9 实例化对象的方法"></a>1.9 实例化对象的方法</h3><ol>
<li>new创建对象</li>
<li>工厂方法返回对象，如String str=String.value(23);</li>
<li>反射手段 如：Object obj =Class.forName(“java.lang.Object”).newInstance();</li>
<li>调用对象的clone()方法</li>
<li>通过I/O流，如利用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ol>
<h3 id="1-10-JDK8新特性"><a href="#1-10-JDK8新特性" class="headerlink" title="1.10 JDK8新特性"></a>1.10 JDK8新特性</h3><ol>
<li>代码更少（增加了新语法：Lambda 表达式）</li>
<li>强大的 Stream API（集合数据的操作）</li>
<li>最大化的减少空指针 异常：Optional 类 的使用</li>
<li>接口的新特性</li>
<li>注解的新特性</li>
<li>集合的底层 源码实现</li>
<li>新日期时间的 api</li>
</ol>
<h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><h3 id="1-ArrayList与LinkedListb比较"><a href="#1-ArrayList与LinkedListb比较" class="headerlink" title="1.ArrayList与LinkedListb比较"></a>1.ArrayList与LinkedListb比较</h3><ol>
<li>前者是Object数组，后者是双向链表</li>
<li>前者支持高效的随即元素访问</li>
<li>插入删除元素区别（自己说）</li>
<li>内存占用，前者一般会预留一些数组空间，后者需要存储前后的结点位置数据</li>
</ol>
<h3 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="2.ArrayList"></a>2.ArrayList</h3><ol>
<li>jdk7中创建便new空间10，jdk8添加元素的时候才会给数组分配空间。</li>
</ol>
<h3 id="3-HashMap与Hashtable"><a href="#3-HashMap与Hashtable" class="headerlink" title="3.HashMap与Hashtable"></a>3.HashMap与Hashtable</h3><ol>
<li>前者非线程安全，后者安全</li>
<li>前者效率高</li>
<li>前者支持Null key，会放在表头</li>
<li>前者初始大小为16，负载因子为0.75，每次扩容乘以二，但是必须为2的次幂。后者初始11，每次 扩容变成2n+1,有参构造设置多少就是多少。</li>
<li>前者当链表的长度大于8(先检查当前数组的产固定，如果当前数组商都小于64，会先进行扩容，而不是转换为红黑树)时，会转换成红黑树。</li>
</ol>
<h3 id="4-HashMap底层实现"><a href="#4-HashMap底层实现" class="headerlink" title="4.HashMap底层实现"></a>4.HashMap底层实现</h3><p>HashMap只锁住了当前链表或红黑树的首结点，只要不发生哈希冲突，就不会产生并发，效率又提升N倍</p>
<p>哈希函数（扰动函数）：hashcode的高16位与低16位进行异或操作再去进行取模操作。</p>
<h3 id="5-jdk8的优化"><a href="#5-jdk8的优化" class="headerlink" title="5.jdk8的优化"></a>5.jdk8的优化</h3><ol>
<li>7没有红黑树结构</li>
<li>链表的插入从头插法改成了尾插法，先扩容再插入改成了先插入再扩容</li>
<li>扩容的时候7需要对原数组的元素进行从新hash定位再新的数组位置，8采用更简单的判断逻辑，位置不变或索引+旧容量大小。</li>
<li>扰动函数，7有四次移位和异或，8只有一次。</li>
<li>多线程情况下1.7会发生死循环，数据丢失，数据覆盖的问题，1.8会有数据覆盖的问题，还有++size会造成多线程同时扩容的问题。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42515631/article/details/112096432?utm_source=app&app_version=4.5.5">HashMap</a></p>
<h4 id="6-HashMap为什么不适用avl树而使用红黑树"><a href="#6-HashMap为什么不适用avl树而使用红黑树" class="headerlink" title="6.HashMap为什么不适用avl树而使用红黑树"></a>6.HashMap为什么不适用avl树而使用红黑树</h4><ol>
<li>AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。</li>
<li>红黑树更适合插入修改密集型任务</li>
<li>通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。</li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h3><p>操作系通是管理计算机硬件与软件资源的应用程序，他的存在屏蔽了硬件层的复杂性，操作系统的内核是操作系统的核心部分，负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。是连接应用程序与硬件的桥梁，决定着系统的性能和稳定性。</p>
<h3 id="1-2-系统调用"><a href="#1-2-系统调用" class="headerlink" title="1.2 系统调用"></a>1.2 系统调用</h3><p>进程在系统上运行的两个级别：</p>
<p>用户态：用户态运行的程序可以直接读取用户应用程序的数据。</p>
<p>系统态:进程可=几乎可以访问计算机的所有资源不受限制。</p>
<p>系统调用分为：进程通信，进程控制，内存管理，文件管理，设备管理。</p>
<h3 id="1-3-进程与线程"><a href="#1-3-进程与线程" class="headerlink" title="1.3 进程与线程"></a>1.3 进程与线程</h3><p>进程就是一个应用程序，而一个进程里面包括可能不止一个线程，如我们运行的java程序，总的来说是一个进程，但是在执行的过程中有着Main主线程，gc垃圾回收线程与异常处理机制等。进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位。线程是cpu调度和分派的基本单位，它可以与同属于一个进程的其他线程共享进程所有的的全部资源。</p>
<h3 id="1-4-进程间的通信方式"><a href="#1-4-进程间的通信方式" class="headerlink" title="1.4 进程间的通信方式"></a>1.4 进程间的通信方式</h3><ol>
<li><p>管道/名管道：用于有情缘关系的父子进程或者兄弟进程之间的通信，存在于内存之中。</p>
</li>
<li><p>命名管道：以磁盘文件的方式存在，可以实现本机任意两个进程通信。半双工。</p>
</li>
<li><p>信号：一种复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
<li><p>消息队列：全双工，存放在内核中，只有在内核重启或者显示删除消息队列的时候，该消息队列才会被删除。一般先进先出，但是可以按照消息读取的类型读取，比FIFO更有优势，而且客服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺陷。 消息队列可以认为是一个全局的一个链表，链表节点钟存放着数据报的类型和内容，有消息队列的标识符进行标记</p>
</li>
<li><p>信号量(Semaphores):信号量是一个计数器，用于多进程对于共享资源的访问，同步进程的作用。</p>
</li>
<li><p>共享内存：多个进程共享一块内存。</p>
</li>
<li><p>套接字：用于客户端与服务端之间的网络通信。</p>
<p>其中共享内存的效率是最高的，将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以。</p>
</li>
</ol>
<h3 id="1-5-线程之间同步方式"><a href="#1-5-线程之间同步方式" class="headerlink" title="1.5 线程之间同步方式"></a>1.5 线程之间同步方式</h3><p>1.互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，互斥对象只有一个，可以保证公共资源不会被多个线程同时访问。sychronized与lock都是这种机制。</p>
<p>2.信号量：允许多个线程访问同一资源，但是需要控制最大的线程数量。</p>
<p>3.事件：wait/notify:通过通知的方式来保持多线程同步。</p>
<h3 id="1-6-进程的调度算法"><a href="#1-6-进程的调度算法" class="headerlink" title="1.6 进程的调度算法"></a>1.6 进程的调度算法</h3><ol>
<li>先到先服务调度算法（FCFS）：从就绪队列中选择最先进入该队列的进程为之分配资源，使它立即执行一直到执行完成或者发生事件发生阻塞放弃占用CPU再重新调度。</li>
<li>短作业优先调度算法（SJF）：从就绪队列选择一个估计运行事件最短的进程为之分配资源，使它立即执行一直到执行完成或者发生事件发生阻塞放弃占用CPU再重新调度。</li>
<li>时间片轮转调度算法：最古老，最简单公平，使用最广的算法，为每个进程分配一个时间段，称作时间片，即该进程可以运行的时间。</li>
<li>多级反馈队列调度算法：既能使高优先级的作业得到响应又能使短作业进程迅速完成，克服了上面调度算法的一些局限性。</li>
<li>优先级调度算法：根据内存要求，时间要求或者其他资源要求为每个进程分配优先级，优先级高的进程先执行。      </li>
</ol>
<h3 id="1-7-内存管理机制"><a href="#1-7-内存管理机制" class="headerlink" title="1.7 内存管理机制"></a>1.7 内存管理机制</h3><p>连续分配管理机制：为用户程序分配一个连续的内存空间，如块式管理</p>
<p>非连续分配管理机制：页式管理，段式管理，段页式管理</p>
<p>1.块式管理：远古时期，将内存分为固定的几个大块，每块中包含一个进程，如果程序运行需要内存的话，就分给他一块，如果程序运行只需要很小的一块内存，就会导致很多内存浪费，浪费的内存被成为碎片。</p>
<p>2.页式管理：把主内存分为很多页，页较小，相对于块式管理的划分力度更大，提高了内存使用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</p>
<p>3.段式管理：页式管理提高了内存使用率，但是页是没有实际意义的。段式管理。每一段的空间比页更小，而且具有意义，每个段定义了一组逻辑信息，例如有主程序段，子程序段，数据段和栈段等。通过段表对应逻辑地址和物理地址。</p>
<p>4.段页式管理机制：结合了段式管理和页式管理的优点，主内存先分成很多段，每一段又分成很多页，段与段以及段的内部都是离散的。</p>
<h3 id="1-8-分页机制与分段机制的区别"><a href="#1-8-分页机制与分段机制的区别" class="headerlink" title="1.8 分页机制与分段机制的区别"></a>1.8 分页机制与分段机制的区别</h3><p>同：都是为了提高内存使用率，减少内存碎片；都是离散存储的。</p>
<p>异：页的大小是固定的，又操作系统决定，段的大小不固定，取决于当前运行的程序。分页只是为了满足操作系统的内存管理需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好的满足用户的需求。</p>
<h3 id="1-9-页表"><a href="#1-9-页表" class="headerlink" title="1.9 页表"></a>1.9 页表</h3><p>页表是放在内存中一个数据结构，存放逻辑地址和物理地址的映射关系。</p>
<p>页表机制缺陷：当虚拟地址空间很大，页面也会很大，会影响内存的性能。为了避免把全部页表放在内存中引入了多级页表，但损失了时间性能。</p>
<h3 id="1-10-快表"><a href="#1-10-快表" class="headerlink" title="1.10 快表"></a>1.10 快表</h3><p>理解为一种特殊的高速缓冲器，内容是一页的全部或者一部分内容，作用与页表相似，但是提高了访问效率。页表做地址转换的话读写内存数据需要访问两次主存，有了块表，只需要访问一次高速缓冲器，一次主存，提高了CPU寻址和指令执行的速度。</p>
<h3 id="1-11-CPU寻址"><a href="#1-11-CPU寻址" class="headerlink" title="1.11 CPU寻址"></a>1.11 CPU寻址</h3><p>虚拟地址转换为物理地址的过程，利用CPU中的MMU（内存管理单元）的硬件。</p>
<h3 id="1-12-为什么需要虚拟地址"><a href="#1-12-为什么需要虚拟地址" class="headerlink" title="1.12 为什么需要虚拟地址"></a>1.12 为什么需要虚拟地址</h3><p>没用虚拟地址的话，程序都是直接访问操作物理地址，可能会对操作系统造成伤害以及给同时运行多个程序造成困难。</p>
<p>优势：1.程序可以使用相邻的虚拟内存地址来访问物理内存中不相邻的的大的内存缓冲区。</p>
<p>​            2.程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区</p>
<p>​            3.不同进程之间的虚拟地址彼此隔离。一个进程中的代码无法更改正有另一个进程或操作系统使用的物理内存。</p>
<h3 id="1-13-什么是虚拟内存"><a href="#1-13-什么是虚拟内存" class="headerlink" title="1.13 什么是虚拟内存"></a>1.13 什么是虚拟内存</h3><p>举一个例子，软件占用内存大于物理内存却可以运行，为每个进程提供了一个一致的，私有的地址空间，让每个进程有了一种自己独享主存的错觉。</p>
<p>虚拟内存是计算机系统内存管理的一种技术，定义了一个连续的虚拟地址空间，把内存扩展到硬盘空间。</p>
<h3 id="1-14-局部性原理"><a href="#1-14-局部性原理" class="headerlink" title="1.14 局部性原理"></a>1.14 局部性原理</h3><p>正因为有着局部性原理，才能够装入部分程序到内存就开始运行。</p>
<p>1.时间局部性：如果程序某条指令一旦被执行，不久之后就可以再次执行；数据被访问过，一段时间之后就会再次被访问，原因就是程序中存在大量的循环操作。</p>
<p>2.空间局部性：一旦程序访问了某个存储单元，不久之后，其附近的单元也将会被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序春芳，顺序执行，数据一般也是以向量，链表，数组，表等形式簇聚存储的。</p>
<p>时间局部性是通过近来使用的指令和数据保存到高速缓冲区中，并使用高速缓存的层次结构实现，空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存其实就是建立了内存-外存的两级存储器结构，利用局部性原理实现高速缓存。</p>
<h3 id="1-15-虚拟内存的技术实现"><a href="#1-15-虚拟内存的技术实现" class="headerlink" title="1.15 虚拟内存的技术实现"></a>1.15 虚拟内存的技术实现</h3><p>建立在离散分配的内存管理方式的基础上。</p>
<p>实现有三种方式：</p>
<p><strong>1.请求分页存储管理：</strong>建立在分页管理上，为了支持虚拟内存而增加了请求调页功能和页面置换功能。在作业开始运行之前，仅装入当前需要的部分段即可运行，在作业过程中如果遇到了当前要访问的页面不在主存则有处理器通知操作系统按照相应的页面置换算法将相应的页面调到主存，同时也可以将暂时不用的页置换到外存中。</p>
<p><strong>2.请求分段存储管理</strong>：在段式管理的基础上，增加了请求调段和分段置换功能，与请求分页存储管理类似，载入部分段便可以运行，中途遇到需要但是不存在内存中的段，便要求调入。当内存满了，又需要加入新的段时，根据置换功能适当调出某个段，以便腾出空间装入新的段。</p>
<p><strong>3.请求段页式存储管理</strong></p>
<h3 id="1-16-这些管理方式会遇到什么问题"><a href="#1-16-这些管理方式会遇到什么问题" class="headerlink" title="1.16 这些管理方式会遇到什么问题"></a>1.16 这些管理方式会遇到什么问题</h3><p><strong>1.缺页中断：</strong>如果需要的数据不在内存中，就是却页或缺段，处理器告诉操作系统将相应的页或段加载到内存中才能继续运行。</p>
<p><strong>2.cpu寻址：</strong>逻辑地址到物理地址的变换。</p>
<h3 id="1-17页面置换算法"><a href="#1-17页面置换算法" class="headerlink" title="1.17页面置换算法"></a>1.17页面置换算法</h3><p>当缺页中断的时候，内存中没有空闲的页面，此时必须选择一个页移除内存，将需要的页置换回来。</p>
<p><strong>OPT置换算法（最佳页面置换算法）：</strong>淘汰的页面是置换永不使用的，或者在长时间内不再被访问的页面，可以保证最低的缺页率。但是人们无法预知什么页面在之后的时间内不会被使用，所以该算法无法实现，一般作为衡量其他置换算法的方法。</p>
<p><strong>FIFO页面置换算法（先进先出置换算法）：</strong>淘汰最先进入内存的页面。</p>
<p><strong>LRU页面置换算法：</strong>赋予页面一个访问字段，表示该页面上次被访问以来经历的时间，淘汰时间最大的那个即最长时间没用的那个页面。</p>
<p><strong>LFU页面置换算法：</strong>淘汰使用频率最少的页面。</p>
<h3 id="1-18-上下文是什么"><a href="#1-18-上下文是什么" class="headerlink" title="1.18 上下文是什么"></a>1.18 上下文是什么</h3><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p>唯一一个不会出现OutOfMemoryError的的内存区域，生命周期随着线程</p>
<p>1.字节码解释器通过改变程序计数器的来依此读取指令，从而实现代码的流程控制，如顺序执行，选择，循环，异常处理。</p>
<p>2.多线程情况下用于记录当前线程所执行的位置，从而当线程被切换回来的时候就能够知道该线程上次运行到哪了。</p>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h3><p>java虚拟机栈是由一个个栈帧组成，而每个栈帧中都有：局部变量表；操作数栈，动态链接，方法出口信息。</p>
<p>1.如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
<p>2.如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。HotSpot虚拟机不支持栈动态扩展。</p>
<p>一个方法如果无限递归，那么迟早会抛出StackOverflowError异常</p>
<p>不断创建新的线程就会导致OutOfMemoryError，应为每个进程的内存是一定的，分给每个线程的内存也是一定的。</p>
<h3 id="3-方法区"><a href="#3-方法区" class="headerlink" title="3.方法区"></a>3.方法区</h3><p>永久代这个玩意其实是HotSpot虚拟机方法区的一种实现，其他虚拟机没用这个永久代说法</p>
<p>为什么要换成元空间：1.元空间使用的是直接内存，如果没有指定元空间的最大大小，那元空间就会动态调整大小，受限于本机内存，虽然还是可能会溢出，但是出现的机率比以前小。2.元空间存放的是类的元数据，这样加载多少类的元数据就不MaxPermSize控制了，而由系统实际可用空间来控制，这样就能加载更多的类了。3.Oracle 可能会将HotSpot 与 JRockit 合二为一</p>
<h3 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4.运行时常量池"></a>4.运行时常量池</h3><ol>
<li>Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有常量池表（编译期生成的各种字面量和符号引用）</li>
<li>1.7之前运行时常量池于与字符串常量池都在方法区中。</li>
<li>1.7将字符串常量池移到了堆中</li>
<li>字符串常量池还是在堆中，运行时常量池在方法区，hotspot此时将方法区实现为元空间。</li>
</ol>
<p>常量池中的常量不仅仅是在编译期产生，而且运行时也会产生，如基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）。</p>
<p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段名称和描述符</li>
<li>方法名称和描述符</li>
</ul>
<p>字符串常量池也是存的字符串对象的引用</p>
<p>符号引用：由于在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，所以如果你在一个类中引用了另一个类，那么你完全无法知道他的内存地址，那怎么办，我们只能用他的类名作为符号引用，在类加载完后用这个符号引用去获取他的内存地址。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaotian15/p/6971353.html">常量池</a></p>
<h3 id="5-java对象创建的过程"><a href="#5-java对象创建的过程" class="headerlink" title="5.java对象创建的过程"></a>5.java对象创建的过程</h3><p><strong>1. 类加载检查：</strong>虚拟机遇到一条new指令的时候，先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过，解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p><strong>2. 分配内存：</strong>类加载检查过后，便需要给新生的对象分配内存，类加载过后便能知道对象所需的内存大小，给对象分配内存就是将堆中的一块内存划分出来，分配的方式有“指针碰撞”和“空闲列表”，选择哪种方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><strong>指针碰撞：</strong></p>
<p>适用场合：堆内存规整（即没有内存碎片）的情况下</p>
<p>原理：用过的内存整合到一边，没有用过的内存放在另一边，中间有一个分界值指针，只需要向着没有用过的内存方向将该指针移动对象大小的内存位置即可。</p>
<p>GC收集器：Serial,ParNew</p>
<p><strong>空闲列表：</strong></p>
<p>适用场合：堆内存不规整的情况下</p>
<p>原理：虚拟机会维护一个列表，该列表中会记录那些内存块是可用的，在分配的时候，找一块足够大的内存划分给对象实例，最后更新列表记录。</p>
<p>GC收集器：CMS</p>
<p><strong>内存分配并发问题：</strong></p>
<ul>
<li>CAS+失败重试</li>
<li>TLAB：为每个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首相在TLAB分配，当对象大于<a target="_blank" rel="noopener" href="https://blog.csdn.net/hfer/article/details/106077631">TLAB</a>中的剩余内存或*TLAB内存已经用尽时，再采用上述的CAS内存进行分配。</li>
</ul>
<p><strong>3.初始化零值</strong></p>
<p>内存分配之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步保证了对象的实例字段在Java代码中可以不赋初始值就可以直接使用，程序能访问到这些字段的数据类型对应的零值。</p>
<p><strong>4.设置对象头</strong></p>
<p>初始化零值之后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。这些信息放在对象头中。另外，根据虚拟机当前的运行状态的不同，如是否启用<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36eedeb3f912">偏向锁</a>等，对象头会有不同的设置方式。</p>
<p><strong>5.执行init方法</strong></p>
<p>之前的工作都完成之后，一个新的对象已经产生了，但是init方法还没有执行，所有字段都还位零。所以还需要执行<init>f方法。</p>
<h3 id="6-对象访问有哪两种方式"><a href="#6-对象访问有哪两种方式" class="headerlink" title="6.对象访问有哪两种方式"></a>6.对象访问有哪两种方式</h3><p>java程序通过栈上的reference数据来操作堆上的具体对象。</p>
<p><strong>1.句柄：</strong>java堆会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中存储了对象的实例数据与类型数据各自的具体地址。</p>
<p><strong>2.直接指针：</strong>这样对象的布局中就需要考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象的地址。</p>
<h3 id="7-JVM内存分配与回收"><a href="#7-JVM内存分配与回收" class="headerlink" title="7.JVM内存分配与回收"></a>7.JVM内存分配与回收</h3><p>一般分配方式：对优先在eden区分配，大对象直接进入老年代，长期存活的对象将进入老年代。</p>
<p>为何大对象（需要大量连续内存空间的对象，如字符串，数组）需要直接进入老年代呢？</p>
<p>为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h3 id="8-如何判断对象已经死亡"><a href="#8-如何判断对象已经死亡" class="headerlink" title="8.如何判断对象已经死亡"></a>8.如何判断对象已经死亡</h3><p><strong>引用计数法：</strong>给对象中添加一个引用计数器，当有一个引用指向他，计数器加一，当引用失效，计数器减一，当计数器为零的时对接就死亡了</p>
<p><strong>可达性分析算法：</strong>通过一系列称为“GC Roots”的对象作为起点，从这些结点向下搜索，结点所走过的路径称为引用链，当一个对象到GC roots没有任何引用链的话，该对象死亡。</p>
<h3 id="9-什么对象可以作为GC-Roots"><a href="#9-什么对象可以作为GC-Roots" class="headerlink" title="9.什么对象可以作为GC Roots"></a>9.什么对象可以作为GC Roots</h3><ol>
<li>虚拟机栈中的引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用对象</li>
<li>本地方法栈中JNI引用对象</li>
</ol>
<h3 id="10-强，软，弱，虚引用"><a href="#10-强，软，弱，虚引用" class="headerlink" title="10.强，软，弱，虚引用"></a>10.强，软，弱，虚引用</h3><h3 id="11-如何判断一个类是无用的"><a href="#11-如何判断一个类是无用的" class="headerlink" title="11.如何判断一个类是无用的"></a>11.如何判断一个类是无用的</h3><ul>
<li>该类所以的实例都已经被回收，也就是java堆中不存在该类的任何实例方法。</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>满足三个条件也不一定会被回收。</p>
<h3 id="12-垃圾收集算法"><a href="#12-垃圾收集算法" class="headerlink" title="12.垃圾收集算法"></a>12.垃圾收集算法</h3><p><strong>标记-清除算法：</strong></p>
<p><strong>复制算法：</strong></p>
<p><strong>标记-整理算法：</strong></p>
<p>所有都是分代收集算法</p>
<p>为什么要分为新生代与老年代？<br>为了提升GC效率</p>
<h3 id="13-垃圾收集器"><a href="#13-垃圾收集器" class="headerlink" title="13.垃圾收集器"></a>13.垃圾收集器</h3><p><strong>1.Serial收集器</strong></p>
<p>串行收集器，一条线程收集垃圾，而且收集过程必须”stop the world”,暂停其他所有线程。简单高效 ，没有线程交互的开销适合Client模式下的虚拟机。</p>
<p>新生代复制算法，老年代标记-整理算法</p>
<p><strong>2.ParNew收集器</strong></p>
<p>Serial收集器的多线程版本，适合Server模式下的虚拟机的首要选择，只有他能与CMS收集器配合工作。</p>
<p>新生代复制算法，老年代标记-整理算法</p>
<p><strong>3.Parallel Scavenge收集器：</strong>jdk8默认收集器</p>
<p>关注的是吞吐量（高效的利用CPU)。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。吞吐量就是cpu中用于运行用户代码的时间与cpu中消耗时间的比值。</p>
<p>多线程，也会stw。</p>
<p><strong>4.Serial Old收集器</strong></p>
<p>Serial收集器的老年代版本，单线程。</p>
<p>用途：jdk5之前与Parallel Scavenge收集器搭配使用；作为CMS收集器的后备方案。</p>
<p><strong>5.Parallel Old收集器</strong></p>
<p>Parallel Scavenge收集器的老年代版本</p>
<p><strong>6.CMS(concurrent mark sweep)收集器</strong></p>
<p>最短回收停顿，这种意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>步骤：</p>
<ol>
<li>初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快。</li>
<li>并发标记，无法保证可达性分析的实时性。</li>
<li>重新标记：停止用户线程，为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段时间比初始标记时间稍长，比并发标记时间短。</li>
<li>并发清除</li>
</ol>
<p>缺点：1. 对cpu资源敏感；2.无法处理浮动垃圾；3.它使用的标记-清除算法会有大量空间碎片产生。</p>
<blockquote>
<p>浮动垃圾：并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理。这些垃圾有个专业名词：浮动垃圾。</p>
</blockquote>
<p><strong>7.G1（Garbage-First)垃圾收集器</strong></p>
<p>针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量的性能特征。</p>
<p>特点：</p>
<ol>
<li>并行与并发：充分利用CPU,多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stw的停顿时间。部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li>分代收集：</li>
<li>空间整合：与CMS不同，整体上来看是基于“标记整理”算法实现的，从局部上来看是基于“复制”算法实现的。</li>
<li>可预测的停顿：可以建立可预测的停顿时间模型，能让使用者明确在指定一个长度为M毫秒的时间片段内。</li>
</ol>
<p>步骤：初始标记，并发标记，最终标记，筛选回收。</p>
<p>G1收集器后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。</p>
<p><strong>8.ZGC收集器</strong></p>
<h3 id="14-类加载过程"><a href="#14-类加载过程" class="headerlink" title="14.类加载过程"></a>14.类加载过程</h3><h3 id="15-JVM字节码文件对象的结构"><a href="#15-JVM字节码文件对象的结构" class="headerlink" title="15.JVM字节码文件对象的结构"></a>15.JVM字节码文件对象的结构</h3><p>对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。</p>
<p>对象头主要包含两部分数据：MarkWord、类型指针。MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据，</p>
<p>实例数据存储代码中所定义的各种类型的字段信息。</p>
<p>对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。</p>
<h2 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h2><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="1-TCP协议如何保证可靠传输"><a href="#1-TCP协议如何保证可靠传输" class="headerlink" title="1.TCP协议如何保证可靠传输"></a>1.TCP协议如何保证可靠传输</h4><ol>
<li>TCP给每个发送的包进行编号，接收方对数据包进行排序，把有序的数据传送给应用层。</li>
<li><strong>校验和：</strong>TCP将保持它首部和数据的校验和，如果收到的段的校验和有差错，TCP将丢弃这个报文段。</li>
<li>TCP接收端会丢弃重复的数据</li>
<li><strong>流量控制：</strong>TCP连接的每一方都有固定大小的缓冲区，TCP接收方只允许发送方发送给接收端缓冲区能接纳的数据。当接收方来不及处理发送发发送的数据，机会提示对方降低发送速率，防止丢包，利用滑动窗口实现流量控制。</li>
<li><strong>拥塞控制：</strong>当网络拥塞时，就会减少数据的发送。</li>
<li><strong>ARQ协议：</strong>基本原理就是每发完一个分组就停止发送，等待对方确认后再发送下一个分组。停止等待ARQ于连续ARQ。</li>
<li><strong>超时重传：</strong>当TCP发送了一个报文段后，会启动一个定时器，如果在规定时间内没有返回确认信号便会重新发送上次的报文段。</li>
</ol>
<h4 id="2-拥塞控制"><a href="#2-拥塞控制" class="headerlink" title="2.拥塞控制"></a>2.拥塞控制</h4><p>在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变化，这就是拥塞。</p>
<p>发送方需要维持一个拥塞窗口的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取拥塞控制窗口和接收方接收窗口中较小的一个。</p>
<p>拥塞控制的四种算法：</p>
<p><strong>慢开始：</strong>当主机开始向网络中发送数据的时候，不会一下子就把发送窗口设置很大，cwnd的初始值为一，没经过一次传播轮次，cwnd加倍。</p>
<p><strong>拥塞避免：</strong>思路是缓慢的让拥塞控制窗口缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1。</p>
<p><strong>快重传与快恢复（fast retransmit and recovery:FRR)：</strong>能够快速恢复丢失的数据包，没有FRR，TCP将会使用定时器来要求传输暂停。再暂停的这段时间内，没有新的或者复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据端，他会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认（dup-ACK)，就会假定这个数据段已经丢失了，并立即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复能够有效工作，但是有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
<h4 id="3-输入URL后的工作过程"><a href="#3-输入URL后的工作过程" class="headerlink" title="3.输入URL后的工作过程"></a>3.输入URL后的工作过程</h4><ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送http请求</li>
<li>服务器处理请求并返回http报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接</li>
</ol>
<h4 id="4-SSL-TLS协议"><a href="#4-SSL-TLS协议" class="headerlink" title="4.SSL/TLS协议"></a>4.SSL/TLS协议</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cnyygydsk/article/details/53197024">SSL协议</a></p>
<p><strong>单项认证：</strong></p>
<ol>
<li><p>   客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p>
</li>
<li><p>   服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p>
</li>
<li><pre><code>客户端使用服务端返回的信息验证服务器的合法性，包括：
</code></pre>
</li>
</ol>
<p>o 证书是否过期</p>
<p>o 发型服务器证书的CA是否可靠</p>
<p>o 返回的公钥是否能正确解开返回证书中的数字签名</p>
<p>o 服务器证书上的域名是否和服务器的实际域名相匹配</p>
<p>验证通过后，将继续进行通信，否则，终止通信</p>
<ol start="4">
<li>   客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li>
<li>   服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</li>
<li>   服务器将选择好的加密方案通过明文方式返回给客户端</li>
<li>   客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码（master_secret = PRF(pre_master_secret, “master secret”, ClientHello.random + ServerHello.random)），用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器。</li>
<li>   服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。<br>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</li>
</ol>
<p><strong>双向认证：</strong></p>
<ol>
<li><p>   客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p>
</li>
<li><p>   服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p>
</li>
<li><pre><code>客户端使用服务端返回的信息验证服务器的合法性，包括：
</code></pre>
</li>
</ol>
<p>o 证书是否过期</p>
<p>o 发型服务器证书的CA是否可靠</p>
<p>o 返回的公钥是否能正确解开返回证书中的数字签名</p>
<p>o 服务器证书上的域名是否和服务器的实际域名相匹配</p>
<p>验证通过后，将继续进行通信，否则，终止通信</p>
<ol start="4">
<li><p>   服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</p>
</li>
<li><p>   验证客户端的证书，通过验证后，会获得客户端的公钥</p>
</li>
<li><p>   客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</p>
</li>
<li><p>   服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</p>
</li>
<li><p>   将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</p>
</li>
<li><p>   客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</p>
</li>
<li><p> 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</p>
</li>
</ol>
<h4 id="5-http的报头"><a href="#5-http的报头" class="headerlink" title="5.http的报头"></a>5.http的报头</h4><p>请求报文：请求的方法，URL,协议版本</p>
<blockquote>
<p>请求的方法：get,post,delete</p>
</blockquote>
<p>回应报文：协议版本，状态码，原因短语</p>
<h4 id="6-状态码"><a href="#6-状态码" class="headerlink" title="6.状态码"></a>6.状态码</h4><p>informational:接收的请求正在处理</p>
<p>success:请求正常处理完毕</p>
<p>redirection:需要进行附加操作以完成请求</p>
<p>client error:服务端无法处理请求</p>
<p>server error:服务器处理请求出错</p>
<h4 id="7-http长连接与短连接"><a href="#7-http长连接与短连接" class="headerlink" title="7.http长连接与短连接"></a>7.http长连接与短连接</h4><p>http1.0默认短连接</p>
<p>http1.1默认长连接</p>
<h4 id="8-如何理解http协议是无状态的"><a href="#8-如何理解http协议是无状态的" class="headerlink" title="8.如何理解http协议是无状态的"></a>8.如何理解http协议是无状态的</h4><p>指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系</p>
<h4 id="9-网络404"><a href="#9-网络404" class="headerlink" title="9.网络404"></a>9.网络404</h4><p>服务器无法提供信息或服务器无法回应且不知道原因</p>
<p>导致这个错误的原因一般有三种：</p>
<ol>
<li>无法再所请求的端口上访问Web站点</li>
<li>Web服务扩展锁定策略阻止本请求</li>
<li>MIME映射策略阻止本请求</li>
</ol>
<h4 id="10-session-cookie-token"><a href="#10-session-cookie-token" class="headerlink" title="10.session,cookie,token"></a>10.session,cookie,token</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chendasheng/article/details/10705418">https://blog.csdn.net/chendasheng/article/details/10705418</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/c880420/article/details/80346127">https://blog.csdn.net/c880420/article/details/80346127</a></p>
</blockquote>
<h4 id="11-http1-0，http1-1与http2-0的主要区别是什么"><a href="#11-http1-0，http1-1与http2-0的主要区别是什么" class="headerlink" title="11.http1.0，http1.1与http2.0的主要区别是什么"></a>11.http1.0，http1.1与http2.0的主要区别是什么</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A">三者区别</a></p>
<h4 id="12-http与https的区别"><a href="#12-http与https的区别" class="headerlink" title="12.http与https的区别"></a>12.http与https的区别</h4><ol>
<li><strong>端口：</strong>http的默认端口是80，https的默认端口是443</li>
<li><strong>安全性与资源消耗：</strong>http运行在TCP之上，，所有的传输都是明文，客户端与服务器端都无法验证对方身份。https是运行在TLS/SSL之上的协议，SSL/TLS运行在TCP之上。所有的传输内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器的证书进行了非对称加密，https的安全性更高，但是回耗费更多的服务器资源。</li>
</ol>
<p><strong>对称加密：</strong>密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的加密算法有DES,AES。</p>
<p><strong>非对称加密：</strong>密钥成对出现（公钥无法推知私钥，私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，加密算法有RSA,DSA。</p>
<h4 id="13-URI与URL的区别"><a href="#13-URI与URL的区别" class="headerlink" title="13.URI与URL的区别"></a>13.URI与URL的区别</h4><p>URI是统一资源标志符，可以唯一标识一个资源</p>
<p>URL是统一资源定位符，可以提供该资源的路径。它是一种具体的URI,可以用来标识一个资源，而且指明了如何locate这个资源</p>
<h4 id="14-HTTP请求的header头解析"><a href="#14-HTTP请求的header头解析" class="headerlink" title="14.HTTP请求的header头解析"></a>14.HTTP请求的header头解析</h4><ol>
<li>Accept:浏览器可以接受的媒体类型，服务端无法返回则返回一个406错误</li>
<li>Accept_Encoding:浏览器接受的编码方法<font color='red'>(不是指字符编码）</font>,通常指压缩方法，是否支持压缩，支持什么压缩方法（gzip,deflate)</li>
<li>Accept-Language:l浏览器申明自己接收的语言</li>
<li>Connection:如keep-alive</li>
<li>Host:指定被请求资源的internet主机和端口号，它通常是从http url中提取出来的</li>
<li>Referer:告诉服务器我是从哪个页面链接过来的,是一个url</li>
<li>User-Agent:客户端使用的操作系统和浏览器的名称和版本</li>
</ol>
<h4 id="15-http回应的header头解析"><a href="#15-http回应的header头解析" class="headerlink" title="15.http回应的header头解析"></a>15.http回应的header头解析</h4><p>Date 服务器端时间<br>Server 服务器端的服务器软件 /2.2.6<br>Etag 文件标识符<br>Content-Encoding传送启用了GZIP压缩 gzip<br>Content-Length 内容长度<br>Content-Type 内容类型</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013252047/article/details/80116742">header</a></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>为什么要用设计模式：模式是一种问题的解决思路，并且已经适用于一个实际环境，并且可以适用于其他环境。设计模式通常是对于某一类软件设计问题的可重用的解决方案，将设计模式引入软件设计和开发过程，其目的在于要重用软件开发经验。</p>
<p>作用：</p>
<ol>
<li>重用设计，比重用代码更加有意义，他会自动带来代码的重用。</li>
<li>在开发文档中使用设计模式词汇可以让其他人更容易理解你的想法和做法，编写开发文档也更方便。</li>
<li>应用设计模式可以让重构系统变得容易，可以确保开发正确的代码，并可以降低在设计和实现中出现错误的可能。</li>
<li>支持变化，可以为重写其他应用程序提供很好的系统架构。</li>
<li>正确的设计模式，可以节省大量时间。</li>
</ol>
<h4 id="1-设计模式六大原则："><a href="#1-设计模式六大原则：" class="headerlink" title="1.设计模式六大原则："></a>1.设计模式六大原则：</h4><ul>
<li>单一职责原则：一个类，方法或者接口只负责一个职责，降低代码复杂度以及变更引起的风险。</li>
<li>接口隔离原则：将不同功能定义在不同接口中实现接口隔离。</li>
<li>依赖倒转原则：针对接口编程，依赖于抽象类或接口而不是依赖于具体实现类。</li>
<li>里氏替换原则：任基类出现的地方，子类一定可以出现。</li>
<li>开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不用去修改源代码，实现一个热插拔的作用。</li>
<li>迪米特法则：每一个对于其他模块要尽可能少的了解和依赖，降低代码耦合度。</li>
<li>合成复用原则：尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</li>
</ul>
<p>其中其他原则都是为了 开放封闭原则</p>
<h4 id="2-说一下你理解的几种设计模式"><a href="#2-说一下你理解的几种设计模式" class="headerlink" title="2.说一下你理解的几种设计模式"></a>2.说一下你理解的几种设计模式</h4><p>简单工厂模式：指由一个工厂对象来创建实例,适用于工厂类负责创建对象较少的情况。例子：Spring 中的 BeanFactory 使用简单工厂模式，产生 Bean 对象。</p>
<p>代理模式为其他对象提供一种代理以控制对这个对象的访问。优点是可以增强目标对象的功能，降低代码耦合度，扩展性好。缺点是在客户端和目标对象之间增加代理对象会导致请求处理速度变慢，增加系统复杂度</p>
<h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h3 id="1-有大量请求同时发送到服务端该如何处理？"><a href="#1-有大量请求同时发送到服务端该如何处理？" class="headerlink" title="1.有大量请求同时发送到服务端该如何处理？"></a>1.有大量请求同时发送到服务端该如何处理？</h3><p>前端：秒杀按钮设计成只能安一次，避免单个用户不断点击发送很多次请求。</p>
<p>秒杀失败提示当前服务忙，等待几秒之后继续能够操作。</p>
<p>后端：</p>
<ol>
<li>静态资源与后台服务进行分离，静态资源比如图片，视频，js,css等放到静态资源服务器。</li>
<li>页面静态化，将数据渲染的动态页面编程一个html静态页面保存起来，如果以后需要再次访问该页面，则将该请求重定向到静态页面。这样就不需要再向数据库或者缓存中拿去数据然后再进行渲染页面，返回到客户端。大大的提高了响应速度，减轻了服务端的负担。nginx就自带了页面静态化的解决方案。</li>
<li>分布式和集群，</li>
<li>反向代理，可以用nginx做负载均衡，避免集群里的应用服务分配请求不均匀导致的个别应用服务器宕机问题。</li>
<li>数据库集群和拆分，一个数据库的并发数是有限的，我们需要用多个数据库来提供服务，增加并发量，这是就需要对数据库做一个集群。数据库本身也是需要进行优化的，我们需要对数据库进行垂直拆分和水平拆分。垂直拆分就是将数据表按照功能模块来进行划分，分别存储在不同的数据库服务器中。水平拆分就是对数据表进行读写分离，一个数据表或许有很多字段，但是有些字段可能在有些页面中读取较多，有些字段在其他页面写入修改较多，这时候我们就应该进行读写分离，将读较多的字段拆分为一个数据表，将写较多的字段拆分为另一个数据表。</li>
<li>使用缓存，比如redis。还可以进行数据预热，将所需要的数据线导入到缓存中去</li>
<li>消息队列流量削峰。</li>
<li>服务降级，当请求到达系统承受能力，可以对其他不核心的功能先关闭，尽可能把系统内存全部给秒杀功能，保证秒杀的正常运行。</li>
<li>服务限流，限流是接口的访问请求进行限流，也可以用rabbitmq进行限流，mq会对队列进行排队限流，一旦超过过期时间，则会丢弃，客户端快速失败进行第二轮重试。</li>
<li>拒绝请求，当服务降级和服务限流不能解决的情况下，最后就只能返回一个错误页面给用户，比如“用户请求过多”“服务繁忙，稍后再试”等，只会发生在服务器过载时候启用，只会存在短暂不可用情况，一旦正常运行的服务器负载降下来，则可以正常请求。</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-sorted-set底层数据结构"><a href="#1-sorted-set底层数据结构" class="headerlink" title="1.sorted set底层数据结构"></a>1.sorted set底层数据结构</h3><ul>
<li>有序集合保存的元素数量小于128个</li>
<li>有序集合保存的所有元素的长度小于64字节</li>
</ul>
<p>此时用的是ziplist，不满足的时候用的skiplist,插入操作的时间复杂度是O（logN)。</p>
<h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h3><ul>
<li><strong>list键</strong>：双向链表</li>
<li><strong>hash键</strong>：字典dict</li>
<li><strong>set键：</strong>intset, hashtable</li>
<li><strong>zset键</strong>：跳跃表zskiplist</li>
</ul>
<h3 id="3-redis与memcached区别"><a href="#3-redis与memcached区别" class="headerlink" title="3.redis与memcached区别"></a>3.redis与memcached区别</h3><ol>
<li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</li>
<li> Redis支持数据的备份，即master-slave模式的数据备份。</li>
<li> Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>redis 单核，mamecahce支持多核,100K 以上数据后者更快</li>
</ol>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h4 id="1-二叉树DFS"><a href="#1-二叉树DFS" class="headerlink" title="1.二叉树DFS"></a>1.二叉树DFS</h4><ol>
<li>确定返回条件（必须有，要不然会出问题，递归到最后一个结点，必须返回一个值回去，有些时候没有返回值，可能在满足遍历到最后一个结点的时候，参数列表中某些值需要改变如集合中添加元素）。</li>
<li>如果中间需要某些结点需要返回的话，写在递归代码的前面，起到剪枝的作用。</li>
<li>递归代码，可以理解成接收下一个结点的返回值，因为有递归所以不满足剪枝条件挥或者返回条件就会递归到最后一个结点。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/22/Note/" data-id="ckrgjiy9z0001kwve9tgw22xl" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/07/21/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/22/Note/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/07/21/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>